<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>(二)关系数据库</title>
      <link href="/2022/03/31/guanxishujuku/"/>
      <url>/2022/03/31/guanxishujuku/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 按照数据模式的三个要素，关系模型由关系数据结构，关系操作集合和关系的完整性约束三部分。</p></blockquote><h3 id="2-1-关系数据库结构以及形式化定义"><a href="#2-1-关系数据库结构以及形式化定义" class="headerlink" title="2.1 关系数据库结构以及形式化定义"></a>2.1 关系数据库结构以及形式化定义</h3><h4 id="2-1-1-关系"><a href="#2-1-1-关系" class="headerlink" title="2.1.1 关系"></a>2.1.1 关系</h4><h5 id="1-域"><a href="#1-域" class="headerlink" title="1.域"></a>1.域</h5><blockquote><p>定义：于是一组具有相同数据类型的集合。</p></blockquote><h5 id="2-笛卡尔积"><a href="#2-笛卡尔积" class="headerlink" title="2.笛卡尔积"></a>2.笛卡尔积</h5><blockquote><p>定义：给定一组域D1,D2…Dn，允许其中某些域是相同的，D1,D2…Dn的笛卡尔积为<br>$$<br>D_1 \times D_2 \times … \times D_n &#x3D; {(d_1,d_2,…,d_n)|d_i \in D_i,i&#x3D;1,2,…,n}<br>$$<br>其中每一个元素$(d_1,d_2,…,d_n)$叫做一个<strong>n元组</strong>，或简称<strong>元组</strong>。元素中每一个值 $d_i$ 都叫做一个分量。</p><p>一个域允许的不同取值个数称为这个域的<strong>基数</strong>；</p><p>若$D_i(i&#x3D;1,2,…,n)$为有限集，其基数为$m_i(i&#x3D;1,2,…,n)$，则$D_1 \times D_2 \times … \times D_n$的技基数为$M &#x3D; \prod{i&#x3D;1}^{n}m_i$</p></blockquote><h5 id="3-关系"><a href="#3-关系" class="headerlink" title="3.关系"></a>3.关系</h5><blockquote><p>关系定义：$D_1 \times D_2 \times … \times D_n $的子集叫做在域$D_1,D_2,…,D_n$上的关系，表示为<br>$$<br>R(D_1,D_2,…,D_n)<br>$$<br>这里R表示关系的名字，n是关系的<strong>目</strong>或<strong>度</strong><br>关系中的每一个元素是关系中的元组，通常用t表示。<br>当n&#x3D;1时，称该关系为<strong>单元关系</strong><br>当n&#x3D;2时，称该关系为<strong>二元关系</strong></p><p>关系是笛卡尔积的有限子集，所以关系也是一张二维表，表的每行对应一个元组，表中的每列对应一个域。由于域可以相同所以给每个列起一个名字，称为属性。n目关系必有n个属性。</p></blockquote><h6 id="候选码，主码，主属性，非主属性，非码属性"><a href="#候选码，主码，主属性，非主属性，非码属性" class="headerlink" title="候选码，主码，主属性，非主属性，非码属性"></a><strong>候选码，主码，主属性，非主属性，非码属性</strong></h6><p><strong>候选码：</strong>某一属性组的值能唯一标识的一个元组，而其子集不能，称该属性组为候选码。<br><strong>主码：</strong>若一个关系中有多个候选码，则选定一个为主码。<br><strong>主属性，非主属性，非码属性：</strong>候选码的诸属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。</p><h6 id="关系可以有三种类型：基本关系（基本表），查询表，视图表"><a href="#关系可以有三种类型：基本关系（基本表），查询表，视图表" class="headerlink" title="关系可以有三种类型：基本关系（基本表），查询表，视图表"></a><strong>关系可以有三种类型：基本关系（基本表），查询表，视图表</strong></h6><p>基本表是实际存在的表，他是实际存储数据的逻辑表示；查询表是查询结果对应的表；视图表是由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。</p><p><strong>当关系作为关系数据模型的数据结构时，需要给予如下限定和扩充</strong></p><p>（1）无限关系在数据库系统中时无意义的。因此，限定关系数据模型中的关系必须是有限集合。</p><p>（2）通过为关系的每个列附加一个属性名的方法取消关系属性的有序性。</p><p><strong>基本关系具有以下六条性质</strong></p><p>（1）列是同质的，即每一列中的数据来自同一个域，都有相同的数据类型。</p><p>（2）不同的列可来自同一个域，称其中每一列为一个属性，不同的属性要给予不同的属性名。</p><p>（3）列的顺序无所谓，即列的顺序可以随意交换。</p><p>（4）任意两个元组的候选码不能取相同的值</p><p>（5）行的顺序无所谓，即行的顺序可以随意交换。</p><p>（6）分量必须取原子值，即每一个数据项都不可再分。</p><h4 id="2-1-2关系模式"><a href="#2-1-2关系模式" class="headerlink" title="2.1.2关系模式"></a>2.1.2关系模式</h4><h5 id="1-关系模式的定义"><a href="#1-关系模式的定义" class="headerlink" title="1.关系模式的定义"></a>1.关系模式的定义</h5><blockquote><p>关系的描述称为关系模式。它可以形式化的表示为R(U,D,DOM,F)</p><p>其中R为关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。</p></blockquote><h5 id="2-关系模式与关系的联系和区别"><a href="#2-关系模式与关系的联系和区别" class="headerlink" title="2.关系模式与关系的联系和区别"></a>2.关系模式与关系的联系和区别</h5><p>关系是关系模式在某一时刻的状态和内容。关系模式是静态的稳定的，而关系是动态的，随时间不断变化的，因为关系操作在不断的更新这数据库中的数据。</p><h4 id="2-1-3-关系数据库"><a href="#2-1-3-关系数据库" class="headerlink" title="2.1.3 关系数据库"></a>2.1.3 关系数据库</h4><p>关系数据库也有型和值之分。<strong>关系数据库的型也称为关系数据库模式，是对关系数据库的描述。</strong></p><p><strong>关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</strong></p><h4 id="2-1-4-关系模型的存储结构"><a href="#2-1-4-关系模型的存储结构" class="headerlink" title="2.1.4 关系模型的存储结构"></a>2.1.4 关系模型的存储结构</h4><p>在关系数据库的物理组织中，有的数据库管理系统中每个表对应一个操作系统文件，将物理数据组织交给操作系统完成；有的关系型数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表，索引等存储结构，并进行存储管理。</p><h3 id="2-2关系操作"><a href="#2-2关系操作" class="headerlink" title="2.2关系操作"></a>2.2关系操作</h3><h4 id="2-2-1-基本的关系操作"><a href="#2-2-1-基本的关系操作" class="headerlink" title="2.2.1 基本的关系操作"></a>2.2.1 基本的关系操作</h4><p>（1）关系模型中常用的的关系操作有<strong>查询操作，插入，删除，修改</strong>操作两大部分。</p><p>（2）关系的查询表达能力很强，是关系操作中最主要的部分。查询操作又可以分为选择，投影，连接，除，并，交，差，笛卡尔积。<strong>其中选择，投影，并，差，笛卡尔积是五种基本操作</strong>。其他操作可以由这五种操作导出。</p><p>（3）关系操作的特点是集合操作方式，即<strong>操作的对象和结果都是集合。</strong></p><h4 id="2-2-2-关系数据语言的分类"><a href="#2-2-2-关系数据语言的分类" class="headerlink" title="2.2.2 关系数据语言的分类"></a>2.2.2 关系数据语言的分类</h4><p>关系代数和关系演算都具有完备的表达能力，称<strong>为关系完备性。</strong></p><h5 id="1-关系代数"><a href="#1-关系代数" class="headerlink" title="1.关系代数"></a>1.关系代数</h5><p>关系代数是用对关系的运算来表达查询要求</p><h5 id="2-关系演算（元组关系演算和域关系演算）"><a href="#2-关系演算（元组关系演算和域关系演算）" class="headerlink" title="2.关系演算（元组关系演算和域关系演算）"></a>2.关系演算（元组关系演算和域关系演算）</h5><p>关系演算用谓词来表达查询要求</p><h5 id="3-结构化查询语言"><a href="#3-结构化查询语言" class="headerlink" title="3.结构化查询语言"></a>3.结构化查询语言</h5><p>结构化查询语言是一种介于关系代数和关系演算的语言，是集查询，数据定义语言，数据操纵语言，数据控制语言与一体的关系数据语言。</p><h3 id="2-3关系完整性"><a href="#2-3关系完整性" class="headerlink" title="2.3关系完整性"></a>2.3关系完整性</h3><blockquote><p>关系的完整性规则是对关系的某种约束条件。也就是说关系的值随着时间内变化时，应该满足一些约束条件。</p><p><strong>关系模型中有三类完整性约束：实体完整性，参照完整性和用户定义完整性。</strong>其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称为<strong>关系的两个不变性。</strong></p></blockquote><h5 id="1-实体完整性"><a href="#1-实体完整性" class="headerlink" title="1.实体完整性"></a>1.实体完整性</h5><p><strong>实体完整性规则：</strong>    若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值。所谓空值就是“不知道”或“不存在”或“无意义”的值。</p><p><strong>对于实体完整性的规则说明如下：</strong></p><p>（1）实体完整性的规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</p><p>（2）现实世界中的实体是可区分的，即它们具有某种唯一性标识。例如每个学生都是独立的个体，是不一样的。</p><p>（3）相应的，关系模型中以主码作为唯一性标识。</p><p>（4）主码中的属性即主属性不能取空值。    </p><h5 id="2-参照完整性"><a href="#2-参照完整性" class="headerlink" title="2.参照完整性"></a>2.参照完整性</h5><h6 id="1-外码的定义"><a href="#1-外码的定义" class="headerlink" title="1.外码的定义"></a>1.外码的定义</h6><blockquote><p>设F是基本关系R中的一个或一组属性，但不是关系R的码，K是基本关系S的主码。如果F与K相应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。</p></blockquote><h6 id="2-参照完整性规则"><a href="#2-参照完整性规则" class="headerlink" title="2.参照完整性规则"></a>2.参照完整性规则</h6><p>若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码K相对应（基本关系R和S不一定是不同的关系），则对于R中的每个元组在F属性上的值必须：</p><ul><li>或者取空值（F的每个属性值都为空值）</li><li>或者等于基本关系S中某个元组的主码值</li></ul><h5 id="3-用户定义完整性"><a href="#3-用户定义完整性" class="headerlink" title="3.用户定义完整性"></a>3.用户定义完整性</h5><p>用户定义完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必循满足的语义要求。</p><h3 id="2-4关系代数"><a href="#2-4关系代数" class="headerlink" title="2.4关系代数"></a>2.4关系代数</h3><p>关系代数是一种抽象的查询语言，<strong>他用对关系的运算来表示查询。</strong></p><p>关系代数的运算按运算符的不同，可以分为<strong>传统的集合运算和专门的关系运算</strong>。</p><h4 id="2-4-1-传统的集合运算"><a href="#2-4-1-传统的集合运算" class="headerlink" title="2.4.1 传统的集合运算"></a>2.4.1 传统的集合运算</h4><p><strong>传统的集合运算是二目运算：包括并，差，交，笛卡尔积。</strong></p><h5 id="（1）并"><a href="#（1）并" class="headerlink" title="（1）并"></a>（1）并</h5><p>关系R与关系S的并记作：<br>$$<br>R \cup S  &#x3D; {t|t \in R \lor t \in S}<br>$$<br>其结果仍为n目关系，由属于R和属于S的元组组成。</p><h5 id="（2）差"><a href="#（2）差" class="headerlink" title="（2）差"></a>（2）差</h5><p>关系R和关系S的差记作<br>$$<br>R-S &#x3D; {t|t \in R \land t \notin S }<br>$$<br>其结果仍为n目关系，由属于R而不属于S的所有元组组成</p><h5 id="（3）交"><a href="#（3）交" class="headerlink" title="（3）交"></a>（3）交</h5><p>关系R和关系S的交记作<br>$$<br>R \cap S &#x3D; {t \in R \land t\in S }<br>$$<br>其结果仍未n目关系，由既属于R有属于S的所有元组组成。</p><h5 id="（4）笛卡尔积"><a href="#（4）笛卡尔积" class="headerlink" title="（4）笛卡尔积"></a>（4）笛卡尔积</h5><p>两个分别为n目和m目的关系R和S的笛卡尔积是一个（n+m）列的元组的集合。元组的前n列是关系R的一个元组，后m列是关系S的一个元组。若R有k1个元组，S有k2个元组则关系R和S的笛卡尔积有k1 x  k2个元组。记作：<br>$$<br>R \times S &#x3D; {\widehat{t_r t_s}|t_r \in R \land t_s \in S}<br>$$</p><h4 id="2-4-2-专门的关系运算"><a href="#2-4-2-专门的关系运算" class="headerlink" title="2.4.2 专门的关系运算"></a>2.4.2 专门的关系运算</h4><p><strong>专门的关系运算包括选择，投影，连接，除运算等。</strong>为了方便叙述先引入几个记号。</p><p>（1）设关系模式为$R(A_1,A_2,…,A_n)$，它的一个关系设为R。$t \in R$表示t是R的一个元组。$t[A_i]$表示元组t中相对应与$A_i$的一个分量。</p><p>（2）若$A&#x3D;{A_{i1},A_{i2},…,A_{ik}}$，其中$A_{i1},A{i2},…,A_{ik}$是$A_1,A_2,…,A_n$中的一部分，则称A为属性列或属性组，$t[A] &#x3D; (t[A_{i1}],t[A_{i2}],…,t[A_{ik}])$表示元组t在属性列A上诸分量的集合，$\overline {A}$则表示在R中去掉A后剩余的属性值。</p><p>（3）R为n目关系，S为m目关系。$t_r \in R$，$t_s \in S$，$\widehat {t_r t_s}$称为元组的连接或元组的串接。他是一个n+m的元组，前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。</p><p>（4）给定一个关系R(X,Z)，X和Z为属性组。当t[X]&#x3D;x时，x在R中的象集定义为：<br>$$<br>Z_t &#x3D; {t[Z]|t \in R,t[X]&#x3D;x}<br>$$</p><h5 id="实例表："><a href="#实例表：" class="headerlink" title="实例表："></a><strong>实例表：</strong></h5><p>表1：Student</p><table><thead><tr><th align="center">学号<br>Sno</th><th align="center">姓名<br>Sname</th><th align="center">性别<br>Ssex</th><th align="center">年龄<br>Sage</th><th align="center">所在系<br>Sdept</th></tr></thead><tbody><tr><td align="center">201215121</td><td align="center">李勇</td><td align="center">男</td><td align="center">20</td><td align="center">CS</td></tr><tr><td align="center">201515122</td><td align="center">刘晨</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td></tr><tr><td align="center">201515123</td><td align="center">王敏</td><td align="center">女</td><td align="center">18</td><td align="center">MA</td></tr><tr><td align="center">201515125</td><td align="center">张立</td><td align="center">男</td><td align="center">19</td><td align="center">IS</td></tr></tbody></table><p>表2：Course</p><table><thead><tr><th align="center">课程号<br>Cno</th><th align="center">课程名<br>Cname</th><th align="center">先行课<br>Cpno</th><th align="center">学分<br>Ccredit</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">数据库</td><td align="center">5</td><td align="center">4</td></tr><tr><td align="center">2</td><td align="center">数学</td><td align="center"></td><td align="center">2</td></tr><tr><td align="center">3</td><td align="center">信息系统</td><td align="center">1</td><td align="center">4</td></tr><tr><td align="center">4</td><td align="center">操作系统</td><td align="center">6</td><td align="center">3</td></tr><tr><td align="center">5</td><td align="center">数据结构</td><td align="center">7</td><td align="center">4</td></tr><tr><td align="center">6</td><td align="center">数据处理</td><td align="center"></td><td align="center">2</td></tr><tr><td align="center">7</td><td align="center">PASCAL语言</td><td align="center">6</td><td align="center">4</td></tr></tbody></table><p>表3：SC</p><table><thead><tr><th align="center">学号<br>Sno</th><th align="center">课程号<br>Cno</th><th align="center">成绩<br>Grade</th></tr></thead><tbody><tr><td align="center">201215121</td><td align="center">1</td><td align="center">92</td></tr><tr><td align="center">201215121</td><td align="center">2</td><td align="center">85</td></tr><tr><td align="center">201215121</td><td align="center">3</td><td align="center">88</td></tr><tr><td align="center">201215122</td><td align="center">2</td><td align="center">90</td></tr><tr><td align="center">201515122</td><td align="center">3</td><td align="center">80</td></tr></tbody></table><h5 id="1-选择"><a href="#1-选择" class="headerlink" title="1.选择"></a>1.选择</h5><h6 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h6><p>选择又称为限制。他是在关系R中选择满足给定条件的诸元组，记作：<br>$$<br>\sigma _F(R) &#x3D; {t|t \in R \land F(t) &#x3D; true}<br>$$<br>其中F表示选择条件，他是一个逻辑表达式，取逻辑值“真”或“假”。</p><p>逻辑表达式F的基本形式：<br>$$<br>X_1 \theta Y_1<br>$$<br>其中$\theta$表示比较运算符，$X_1,Y_1$表示属性名或者常量。</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>$\lnot$</td><td>非</td></tr><tr><td>$\land$</td><td>与</td></tr><tr><td>$\lor$</td><td>或</td></tr></tbody></table><h6 id="（2）例子"><a href="#（2）例子" class="headerlink" title="（2）例子"></a>（2）例子</h6><p>例1：查询信息系（IS）系全体学生<br>$$<br>\sigma_{Sdept &#x3D; ‘IS’} (Student)<br>$$</p><table><thead><tr><th align="center">学号<br>Sno</th><th align="center">姓名<br>Sname</th><th align="center">性别<br>Ssex</th><th align="center">年龄<br>Sage</th><th align="center">所在系<br>Sdept</th></tr></thead><tbody><tr><td align="center">201515125</td><td align="center">张立</td><td align="center">男</td><td align="center">19</td><td align="center">IS</td></tr></tbody></table><p>例2：查询年龄小于20岁的学生<br>$$<br>\sigma_{Sage&lt;20}(Student)<br>$$</p><table><thead><tr><th align="center">学号<br>Sno</th><th align="center">姓名<br>Sname</th><th align="center">性别<br>Ssex</th><th align="center">年龄<br>Sage</th><th align="center">所在系<br>Sdept</th></tr></thead><tbody><tr><td align="center">201515122</td><td align="center">刘晨</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td></tr><tr><td align="center">201515123</td><td align="center">王敏</td><td align="center">女</td><td align="center">18</td><td align="center">MA</td></tr><tr><td align="center">201515125</td><td align="center">张立</td><td align="center">男</td><td align="center">19</td><td align="center">IS</td></tr></tbody></table><h5 id="2-投影"><a href="#2-投影" class="headerlink" title="2.投影"></a>2.投影</h5><h6 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h6><p>关系R上的投影是从R中选择出若干属性列组成新的关系。记作：<br>$$<br>\Pi_A(R)&#x3D;{ t[A]|t \in R }<br>$$<br>其中A为R中的属性列</p><h6 id="2-例子"><a href="#2-例子" class="headerlink" title="2.例子"></a>2.例子</h6><p>例1：查询学生的姓名和所在系，即求Student关系上学生姓名和所在系两个属性的投影。<br>$$<br>\Pi_{Sname,Sdept}(Student)<br>$$</p><table><thead><tr><th align="center">姓名<br>Sname</th><th align="center">所在系<br>Sdept</th></tr></thead><tbody><tr><td align="center">李勇</td><td align="center">CS</td></tr><tr><td align="center">刘晨</td><td align="center">CS</td></tr><tr><td align="center">王敏</td><td align="center">MA</td></tr><tr><td align="center">张立</td><td align="center">IS</td></tr></tbody></table><p>例2：查询学生关系Student中有那些系，即查询学生关系Student上所在系属性上的投影<br>$$<br>\Pi_{Sdept}(Student)<br>$$</p><table><thead><tr><th align="center">所在系<br>Sdept</th></tr></thead><tbody><tr><td align="center">CS</td></tr><tr><td align="center">MA</td></tr><tr><td align="center">IS</td></tr></tbody></table><h5 id="3-连接"><a href="#3-连接" class="headerlink" title="3.连接"></a>3.连接</h5><p>连接分为<strong>条件连接（$\theta$连接），等值连接，自然连接</strong></p><h6 id="1-条件连接也称为-theta-连接。"><a href="#1-条件连接也称为-theta-连接。" class="headerlink" title="1.条件连接也称为$\theta$连接。"></a>1.条件连接也称为$\theta$连接。</h6><p>它是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。</p><p>记作：<br>$$<br>R\bowtie_{A \theta B} S &#x3D; { \widehat{t_r t_s}|t_r \in R \land t_s \in S \land t_r[A]\theta t_s[B] }<br>$$<br>其中A和B分别为R与S上列数相等且可比的属性组，$\theta$为比较运算符。连接运算从R和S的笛卡尔积R x S中选取R关系在A属性组上的值与S关系在B属性主上的值满足比较关系$\theta$的元组</p><h6 id="2-等值连接"><a href="#2-等值连接" class="headerlink" title="2.等值连接"></a>2.等值连接</h6><p>$\theta$为’&#x3D;’的连接为等值连接。它是从关系R和关系S的广义笛卡尔积中选取A，B属性值相等的那些元组，即等值连接为：<br>$$<br>R \bowtie_{A&#x3D;B} S &#x3D; { \widehat{t_rt_s}|t_r \in R \land t_s \in S \land t_r[A]&#x3D;t_s[B] }<br>$$</p><h6 id="3-自然连接"><a href="#3-自然连接" class="headerlink" title="3.自然连接"></a>3.自然连接</h6><p>自然连接是一种特殊的等值连接，他要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。若R和S中具有相同的属性列B，U为R和S全体属性集合，则自然连接可记作：<br>$$<br>R \bowtie S &#x3D; { \widehat{t_rt_s}[U-B]|t_r \in R \land t_s \in S \land t_r[B] &#x3D; t_s[B] }<br>$$<br><strong>一般的连接操作从行的角度进行运算，但自然连接还需要取消重复列，所以同时从行和列的角度进行运算。</strong></p><p>4.悬浮元组，外连接，左外连接，右外连接</p><p><strong>悬浮元组：</strong>被舍弃的元组称为悬浮元组</p><p><strong>外连接：</strong>如果把把悬浮元组也保存在结果关系中，而在其他属性上填空值（NULL），那么这种连接就叫做外连接。</p><p><strong>左外连接：</strong>如果只保留左边关系R中的悬浮元组叫做左外连接</p><p><strong>右外连接：</strong>如果只保留右边关系R中的悬浮元组叫做右外连接</p><h5 id="4-除"><a href="#4-除" class="headerlink" title="4.除"></a>4.除</h5><h6 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h6><p>设在关系R除以关系S的结果为关系T，则<strong>T包含所有在R但不在S中的属性及其值，且T的元组与S的的元组的所有组合都在R中。</strong></p><p>下面用<strong>象集</strong>来定义除法：</p><p>给定关系R(X,Y)和S(Y,Z),其中X,Y,Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。</p><p>R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上的分量值x的象集$Y_x$包含S在Y上投影的集合。记作：<br>$$<br>R \div S &#x3D; {t_r[X]|t_r \in R \land \Pi_Y(S) \subseteq Y_x}<br>$$<br>其中$Y_x$为x在R上的象集，$x &#x3D; t_r[X]$。</p><p>除操作是同时从行和列角度操作的。</p><h6 id="2-例子-1"><a href="#2-例子-1" class="headerlink" title="2.例子"></a>2.例子</h6><p>设关系R，S分别为下图的表，$R \div S$的结果也如下图</p><p>在关系R中，A可以取4个值{a1,a2,a3,a4},其中：</p><p>a1的象集为：{(b1,c2),(b2,c3),(b2,c1)}</p><p>a2的象集为：{(b3,c7),(b2,c3)}</p><p>a3的象集为：{(b4,c6)}</p><p>a4的象集为：{(b6,c6)}</p><p>S在（B，C）上的投影为{(b1,c2),(b2,c3),(b2,c1)}</p><p>显然只有a1的象集(B,C)a1包含了S在(B,C)属性组上的投影，所以<br>$$<br>R \div S &#x3D; {a}<br>$$</p><p>R:</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c2</td></tr><tr><td>a2</td><td>b3</td><td>c7</td></tr><tr><td>a3</td><td>b4</td><td>c6</td></tr><tr><td>a1</td><td>b2</td><td>c3</td></tr><tr><td>a4</td><td>b6</td><td>c6</td></tr><tr><td>a2</td><td>b2</td><td>c3</td></tr><tr><td>a1</td><td>b2</td><td>c1</td></tr></tbody></table><p>S:</p><table><thead><tr><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>b1</td><td>c2</td><td>d1</td></tr><tr><td>b2</td><td>c1</td><td>d1</td></tr><tr><td>b2</td><td>c3</td><td>d2</td></tr></tbody></table><p>$R \div S$</p><table><thead><tr><th align="center">A</th></tr></thead><tbody><tr><td align="center">a1</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(一)数据库绪论</title>
      <link href="/2022/03/29/shujukuxitongxulun/"/>
      <url>/2022/03/29/shujukuxitongxulun/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据库系统概述"><a href="#1-数据库系统概述" class="headerlink" title="1.数据库系统概述"></a>1.数据库系统概述</h3><h4 id="1-1数据库的4个基本概念"><a href="#1-1数据库的4个基本概念" class="headerlink" title="1.1数据库的4个基本概念"></a>1.1数据库的4个基本概念</h4><p><u>数据，数据库，数据库管理系统，数据库系统</u></p><p><strong>数据</strong>：数据是数据库中存储的基本对象。描述事物的符号记录称为数据。数据的含义称为数据的语义，数据与其语义是不可分的。</p><p><strong>数据库</strong>：数据库是长期存储在计算机内，有组织，可共享的大量数据的集合。数据可中的数据按一定的数据模型组织，描述和存储，<strong>具有较小的冗余度，较高的数据独立性和易扩展性</strong>，并可为各种用户共享。概括来说数据库<strong>具有永久存储，有组织和可共享</strong>三个基本特点。</p><p><strong>数据库管理系统</strong>：主要功能包括以下几个方面：</p><p>(1) 数据库定义功能(DDL)<br>(2)数据库组织，存储和管理<br>(3)数据操纵功能(DML)<br>(4)数据库的事务管理和运行管理<br>(5)数据库的建立和维护功能<br>(6)其他功能</p><p><strong>数据库系统：</strong>数据库系统是由数据库，数据库管理系统，应用程序和数据库管理员组成的存储，管理，处理和维护数据的系统。</p><h4 id="1-2数据库管理技术的产生的发展"><a href="#1-2数据库管理技术的产生的发展" class="headerlink" title="1.2数据库管理技术的产生的发展"></a>1.2数据库管理技术的产生的发展</h4><h5 id="1-人工管理阶段"><a href="#1-人工管理阶段" class="headerlink" title="1.人工管理阶段"></a>1.人工管理阶段</h5><p>硬件状况：外存只有纸带，卡片，磁带，没有磁盘等直接存取的存储设备。</p><p>软件状况：没有操作系统，没有管理数据的专门软件</p><p>数据处理方式：批处理</p><p>特点：数据不保存；应用程序管理数据；数据不共享；数据不具有独立性</p><h5 id="2-文件系统阶段"><a href="#2-文件系统阶段" class="headerlink" title="2.文件系统阶段"></a>2.文件系统阶段</h5><p>硬件状况：有了磁盘，磁鼓的直接存储设备</p><p>软件状况：操作系统中已经有了专门的数据管理软件，一般称为文件系统</p><p>数据处理方式：批处理，联机实时处理</p><p>特点：数据可以长期保存；由文件系统管理数据，数据共享性差，冗余度大；数据独立性差。</p><h5 id="3-数据库管理阶段"><a href="#3-数据库管理阶段" class="headerlink" title="3.数据库管理阶段"></a>3.数据库管理阶段</h5><p>硬件状况：已有大容量磁盘，硬件价格下降</p><p>软件状况：数据库管理系统</p><p>从文件系统到数据库系统标志这数据管理技术的飞跃</p><p>特点：</p><p>1.数据结构化：数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库与文件系统的本质区别。</p><p>2.数据的共享性高，冗余度低且易扩充：数据共享可以大大减少数据冗余，节约存储空间。数据共享还能够避免数据之间的不相容性与不一致性。</p><p>3.数据独立性高：物理独立性是指应用程序与数据库中数据的物理存储是相互独立的。逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</p><p>4.数据有数据库管理系统统一管理和控制：数据的安全性保护，数据的完整性保护，并发控制，数据库恢复。</p><h3 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2.数据模型"></a>2.数据模型</h3><p>数据模型是一种模型，是对现实世界数据特征的抽象。</p><p>数据模型是数据库系统的核心和基础。</p><h4 id="2-1-两类数据模型"><a href="#2-1-两类数据模型" class="headerlink" title="2.1 两类数据模型"></a>2.1 两类数据模型</h4><h5 id="1-概念模型"><a href="#1-概念模型" class="headerlink" title="1.概念模型"></a>1.概念模型</h5><p>（1）实体：客观存在并可相互区别的事物称为实体。</p><p>（2）属性：实体具有的某一特征称为属性</p><p>（3）码：唯一表示实体的属性集称为码</p><p>（4）实体型 ：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</p><p>（5）实体集：同一类型实体的集合称为实体集</p><p>（6）联系：实体之间的联系通常是指不同实体集之间的联系。实体之间的联系有一对一，一对多和多对多等多种类型。</p><p>概念模型的一种表示方法：实体-模型方法，该方法用E-R图来描述现实世界的概念模型。</p><h5 id="2-1逻辑模型和物理模型"><a href="#2-1逻辑模型和物理模型" class="headerlink" title="2.1逻辑模型和物理模型"></a>2.1逻辑模型和物理模型</h5><p>逻辑模型包括：层次模型，网状模型，关系模型，面向对象数据模型，对象关系数据模型，半结构化数据模型</p><p>物理模型是对数据最底层的抽象，他描述数据在系统内部的表示方式和存取方法，或在磁盘磁带上的存储方式和存取方法，是面向计算机系统的。</p><h5 id="2-2数据模型的组成要素"><a href="#2-2数据模型的组成要素" class="headerlink" title="2.2数据模型的组成要素"></a>2.2数据模型的组成要素</h5><blockquote><p>数据模型是严格定义的一组概念的集合。这些概念精确的描述了系统的静态特性，动态特性和完整性约束条件。</p></blockquote><p>数据模型通常由数据结构，数据操作，数据的完整性约束条件三部分组成。</p><h6 id="1-数据结构（系统的静态特性）"><a href="#1-数据结构（系统的静态特性）" class="headerlink" title="1.数据结构（系统的静态特性）"></a>1.数据结构（系统的静态特性）</h6><p>数据结构描述数据库的组成对象以及对象之间的联系</p><h6 id="2-数据操作（系统的动态特性）"><a href="#2-数据操作（系统的动态特性）" class="headerlink" title="2.数据操作（系统的动态特性）"></a>2.数据操作（系统的动态特性）</h6><h6 id="3-数据的完整性约束条件"><a href="#3-数据的完整性约束条件" class="headerlink" title="3.数据的完整性约束条件"></a>3.数据的完整性约束条件</h6><p>数据的完整性约束条件是一组完整性规则</p><h5 id="2-2常用的数据模型"><a href="#2-2常用的数据模型" class="headerlink" title="2.2常用的数据模型"></a>2.2常用的数据模型</h5><h6 id="1-层次模型"><a href="#1-层次模型" class="headerlink" title="1.层次模型"></a>1.层次模型</h6><p>1.层次模型的数据结构：<br>在数据库定义中满足下面两个条件的基本层次联系的集合为层次模型.：<br>（1）有且只有一个结点没有双亲结点，这个结点称为根节点。<br>（2）根节点以外的其他节点有且只有一个双亲结点<br>层次模型像一颗倒立的树，结点的双亲是唯一的。</p><p>2.层次模型的数据操纵和完整性约束<br>层次模型的数据操纵主要有插入，删除，查询，修改；进行插入删除修改时要符合数据的完整性约束。</p><p>3.层次模型的优缺点<br>优点：<br>（1）层次模型的数据结构比较简单清晰<br>（2）层次模型的查询效率高<br>（3）层次模型提供了良好的完整性支持</p><p>缺点：<br>（1）现实世界中有许多关系是非层次性的，例如多对多的关系不能用层次模型来表示。<br>（2）如果一个结点有多个双亲结点，应用程序的编写会比较复杂。<br>（3）查询子女节点必须通过双亲结点<br>（4）由于结构严密，层次命令趋于程序化</p><h6 id="2-网状模型"><a href="#2-网状模型" class="headerlink" title="2.网状模型"></a>2.网状模型</h6><p>1.网状模型的数据结构<br>在数据库中，把满足以下两个条件的的基本层次联系集合称为网状模型：<br>（1）允许一个以上节点无双亲<br>（2）一个节点可以有多余一个的双亲</p><p>2.网状模型的数据操纵与完整新约束<br>网状模型中一般没有层次模型那样严格的完整性约束条件，但具体的网状模型系统对数据操纵都加了一些限制，提供了一定的完整性约束。</p><p>3.网状模型的优缺点<br>优点：<br>（1）能够更为直接的描述现实世界<br>（2）具有良好的性能，存取效率较高</p><p>缺点：<br>（1）结构比较复杂，而且随着应用环境的扩大，越来越复杂。<br>（2）网状模型的DDL，DML复杂。用户不易掌握使用。<br>（3）由于记录之间的联系是通过存取路径实现的，应用程序</p><h6 id="3-关系模型"><a href="#3-关系模型" class="headerlink" title="3.关系模型"></a>3.关系模型</h6><p>1.关系模型的数据结构</p><p>关系模型与以往的模型不同，他是建立在严格的数学概念的基础上的。从用户观点看，关系模型有一组关系组成。每个关系的数据结构是一张规范的二维表。</p><blockquote><p>关系模型中的一些术语：</p><p>关系：一个关系对应通常说的一张表</p><p>元组：表中的一行即为一个元组</p><p>属性：表中的一列即为一个属性，给每一个属性起一个名称即为属性名。</p><p>码：也成为码键。表中的某个属性组，它可以唯一确定一个元组。</p><p>域：域是一组具有相同数据类型值得集合。属性的取值范围来自于某个域。</p><p>分量：元组中的一个属性值。</p><p>关系模式：对关系模式的描述，一般表示为：</p><p>关系名（属性1，属性2，…，属性n）</p></blockquote><p>关系模式要求关系必须是规范化的，及要求关系必须满足一定的规范条件，例如，关系的每一个分量必须是一个不可分的数据项。</p><p>2.关系模型的数据操纵与完整性约束</p><p>关系模型的数据操纵主要包括查询（DQL），插入，删除，更新（DML）。这些操作必须满足关系的完整性约束。包括实体完整性，参照完整性，用户定义完整性。</p><p>操作对象和操作结果都是关系，关系模型把存取路径向用户隐蔽起来，用户只要指出“干什么”或“找什么”，不必详细说明“怎么干”或怎么找，从而大大提高数据独立性，提升了用户生产率。</p><p>3.关系模型的优缺点</p><p>（1）关系模型与格式化模式不同，他是建立在严格的数学概念基础之上的。</p><p>（2）关系模型的概念单一，无论是实体还是实体之间的联系，都用关系来表示。对数据的检索和更新结果也是关系（即表）。所以其数据结构简单，清晰，用户易懂易用。</p><p>（3）关系模型的存取路径对用户透明，从而具有更高的数据独立性，更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。</p><h3 id="3-数据库系统的结构"><a href="#3-数据库系统的结构" class="headerlink" title="3.数据库系统的结构"></a>3.数据库系统的结构</h3><h4 id="3-1数据库系统模式的概念"><a href="#3-1数据库系统模式的概念" class="headerlink" title="3.1数据库系统模式的概念"></a>3.1数据库系统模式的概念</h4><p><strong>在数据模式中有“型” 和 “值”的概念。</strong>型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。例如学生记录定义为（学号，姓名，性别，系别，年龄，籍贯）这样的记录型，而（201315130，李明，男，计算机系，19，江苏南京市）则是该记录型的一个记录值。</p><p><strong>模式是数据库中全体数据的逻辑结构和特征的描述，</strong>它仅仅涉及型的描述，不涉及具体的值，模式的一个具体的值称为模式的一个实例，同一个模式可以有很多实例。</p><p><strong>模式是相对稳定的，而实例是相对变动的。</strong></p><h4 id="3-2数据库系统的三级模式结构"><a href="#3-2数据库系统的三级模式结构" class="headerlink" title="3.2数据库系统的三级模式结构"></a>3.2数据库系统的三级模式结构</h4><blockquote><p>数据库的三级模式结构是指数据库系统由外模式，模式，内模式三级构成。</p></blockquote><h5 id="1-模式"><a href="#1-模式" class="headerlink" title="1.模式"></a>1.模式</h5><p>模式也成为逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。它是数据库系统模式结构的中间层，及不涉及数据的物理存储细节和硬件环境，由于具体的应用程序，所使用的应用开发工具及高级程序设计语言无关。</p><p>注意：<br>1.一个数据库只有一个模式<br>2.数据库管理系统提供模式定义语言（模式DDL）来严格定义模式</p><h5 id="2-外模式"><a href="#2-外模式" class="headerlink" title="2.外模式"></a>2.外模式</h5><p>外模式也成为子模式或用户模式，他是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p><p>注意：</p><p>1.外模式通常是模式的子集，一个数据库可以有多个外模式。<br>2.即使对模式中的同一数据，在外模式中的结构类型长度保密等级等都可以不同。<br>3.一个应用程序只能使用一个外模式<br>4.外模式是保证数据库安全性的一个有力措施，每个用户只能看见和访问所对应的外模式中的数据，数据库中的其余数据是不可见的。<br>5.数据库管理系统提供外模式的定义语言（外模式DDL）来严格定义外模式。</p><h5 id="3-内模式"><a href="#3-内模式" class="headerlink" title="3.内模式"></a>3.内模式</h5><p>内模式也成为存储模式，<strong>一个数据库只有一个内模式</strong>他是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</p><h4 id="3-3数据库系统的二级映像功能与数据独立性"><a href="#3-3数据库系统的二级映像功能与数据独立性" class="headerlink" title="3.3数据库系统的二级映像功能与数据独立性"></a>3.3数据库系统的二级映像功能与数据独立性</h4><p>为了在系统内部实现这三个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：外模式&#x2F;模式映像，模式&#x2F;内模式影响。</p><p>这两层映像保证了数据库系统中数据能够具有较高的逻辑独立性和物理独立性。</p><h5 id="1-外模式-x2F-模式映像"><a href="#1-外模式-x2F-模式映像" class="headerlink" title="1.外模式&#x2F;模式映像"></a>1.外模式&#x2F;模式映像</h5><p>模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构，对应于一个模式可以有任意多个外模式，对于每一个外模式，数据库系统都有一个外模式&#x2F;模式映像，它定义了该外模式与模式之间的定义关系，这些映像定义通常包含在各自外模式的描述中。</p><p>当模式改变时，由数据库管理员对各个外模式&#x2F;模式映像做出相应改变。可以使外模式保持不变，应用程序是一句数据的外模式编写的。从而应用程序不必修改，保证了数据与应用程序的逻辑独立性，简称数据的逻辑独立性。</p><h5 id="2-模式-x2F-内模式映像"><a href="#2-模式-x2F-内模式映像" class="headerlink" title="2.模式&#x2F;内模式映像"></a>2.模式&#x2F;内模式映像</h5><p>数据库中只有一个模式，也只有一个内模式，所以模式&#x2F;内模式映像是唯一的。它定义了数据全局逻辑结构和存储结构之间的关系，该映像定义通常包含在对模式的描述中。当数据库的存储结构改变时，由数据库管理员对模式&#x2F;内模式映像做出相应改变。保证了数据与应用程序的物理独立性，简称为数据的物理独立性。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git笔记</title>
      <link href="/2022/03/22/gitbiji/"/>
      <url>/2022/03/22/gitbiji/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Git是一个免费的开源的分布式版本控制系统。"><a href="#1-Git是一个免费的开源的分布式版本控制系统。" class="headerlink" title="1.Git是一个免费的开源的分布式版本控制系统。"></a>1.Git是一个免费的开源的分布式版本控制系统。</h3><p>Git官网：git-scm.com</p><p>版本控制的核心思想：记录文件修改历史</p><h3 id="2-GIt的工作机制"><a href="#2-GIt的工作机制" class="headerlink" title="2.GIt的工作机制"></a>2.GIt的工作机制</h3><p>分为三个部分<br>工作区git add -&gt; 暂存区 git commit-&gt; 本地库<br>写代码                 临时存储                     历史版本</p><h3 id="3-Git常用命令"><a href="#3-Git常用命令" class="headerlink" title="3.Git常用命令"></a>3.Git常用命令</h3><p>命令名称                                                          作用<br>git config –global user.name 用户名        设置用户签名<br>git config –global user.email 邮箱            设置用户签名<br>git init                                                         初始化本地库<br>git statua                                                    查看本地库状态<br>git add 文件名                                            添加到暂存区<br>git rm –cached 文件名                               将暂存区的文件删掉<br>git commit -m “日志信息” 文件名              添加到本地库<br>git reflog                                                     查看历史版本<br>git log                                                         查看详细的版本信息<br>git reset –hard 版本号                                版本穿梭</p><h3 id="4-Git分支操作"><a href="#4-Git分支操作" class="headerlink" title="4.Git分支操作"></a>4.Git分支操作</h3><p><strong>什么是分支：</strong>在版本控制中，同时推进多个任务，为每个任务，我们可以单独创建一个分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，在开发自己分支的时候，不会影响主线分支的运行。分支的底层是指针的作用。</p><p><strong>分支的操作：</strong><br>命令名称                                                          作用<br>git branch 分支名                                     创建分支<br>git branch -v                                             查看分支<br>git checkout 分支名                                  切换分支<br>git merge 分支                                          把指定的分支合并到当前分支上</p><p><strong>分支合并产生冲突：</strong><br>原因：合并分支时，两个分支在同一个文件的同一个位置有两套不同的修改。Git无法决定使用哪一个。必须认为决定新代码内容。</p><h3 id="5-Git团队协助机制"><a href="#5-Git团队协助机制" class="headerlink" title="5.Git团队协助机制"></a>5.Git团队协助机制</h3><p>团队内协作<br>push            clone           pull<br>跨团队协作<br>fork         clone       push        Pull request        merge         </p><h3 id="6-GitHub操作"><a href="#6-GitHub操作" class="headerlink" title="6.GitHub操作"></a>6.GitHub操作</h3><p><strong>1-.创建远程库</strong><br>远程库的名称最好和本地库的名称相同<br><strong>2-.创建远程仓库别名</strong><br>git remote -v 查看当前所有远程地址别名<br>git remote add 别名 远程地址<br><strong>3-.推送本地库到远程库</strong><br>git push 别名 分支<br>第一次登录会处理一个登陆凭证的东西：可以使用浏览器绑定或者使用token绑定。<br><strong>4-.克隆代码到本地库</strong><br>克隆会自动进行三个操作：1.拉取代码 2.初始化本地库 3.创建别名<br><strong>5-.邀请加入团队</strong><br>Setting -&gt; Manage access<br><strong>6-.SSH免密登录</strong><br>本地生成SSH密钥：ssh –keygen -t rsa  -C “描述”<br>私钥：id_rsa<br>公钥：id_rsa.pub</p><p>公钥填入GitHub：Settings-&gt;SSH and GPG keys-&gt;添加公钥</p><h3 id="7-IDEA集成Git"><a href="#7-IDEA集成Git" class="headerlink" title="7.IDEA集成Git"></a>7.IDEA集成Git</h3><h4 id="1-初始化配置"><a href="#1-初始化配置" class="headerlink" title="1.初始化配置"></a>1.初始化配置</h4><h5 id="1-配置Git忽略文件"><a href="#1-配置Git忽略文件" class="headerlink" title="1.配置Git忽略文件"></a>1.配置Git忽略文件</h5><p>创建忽略规则文件 xxxx.ignore(前缀随便起，建议git.ignore)<br>这个文件的存放位置哪里都行，但是便于让~&#x2F;.gitconfig文件引用，建议也放在用户家目录下<br>git.ignore文件模板内容如下：</p><pre class="line-numbers language-none"><code class="language-none"># Compiled class file*.class# Log file*.log# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp&#x2F;# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rarhs_err_pid*.classpath.project.settingstarget.idea*.iml       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在用户的家目录下配置.gitconfig</p><pre class="line-numbers language-none"><code class="language-none">[core]      excludesfile &#x3D; C:&#x2F;Users&#x2F;HUAN&#x2F;git.ingore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="2-定位git程序"><a href="#2-定位git程序" class="headerlink" title="2.定位git程序"></a>2.定位git程序</h5><p>File-&gt;Settings-&gt;VersionControl-&gt;Git</p><h4 id="2-IDEA的git库操作"><a href="#2-IDEA的git库操作" class="headerlink" title="2.IDEA的git库操作"></a>2.IDEA的git库操作</h4><h4 id="1-初始化git库"><a href="#1-初始化git库" class="headerlink" title="1.初始化git库"></a>1.初始化git库</h4><p>   VCS-&gt; Create Git Repository</p><h4 id="2-添加到暂存区"><a href="#2-添加到暂存区" class="headerlink" title="2.添加到暂存区"></a>2.添加到暂存区</h4><p>第一种方法：在要添加的文件处右键-&gt;Git-&gt;Add(快捷键Ctrl + Alt +A)<br>第二种方法：右键项目的根目录右键-&gt;Git-&gt;Add</p><h4 id="3-提交到本地库"><a href="#3-提交到本地库" class="headerlink" title="3.提交到本地库"></a>3.提交到本地库</h4><p>右键项目的根目录右键-&gt;Git-&gt;Commit Directory…</p><h4 id="4-切换版本"><a href="#4-切换版本" class="headerlink" title="4.切换版本"></a>4.切换版本</h4><p>查看版本信息：左下角git -&gt;log<br>切换版本：在log中选中版本右键-&gt;Checkout Revision …</p><h4 id="5-创建分支"><a href="#5-创建分支" class="headerlink" title="5.创建分支"></a>5.创建分支</h4><p>右键项目名称-&gt;Git-&gt;Repository-&gt;Branches…-&gt;New branch<br>                           或者<br>                   单击右下角Git:master-&gt;New branch</p><h4 id="6-切换分支"><a href="#6-切换分支" class="headerlink" title="6.切换分支"></a>6.切换分支</h4><p>单击右下角Git:hot-fix-&gt;点击你要切换的分支-&gt;Checkout</p><h4 id="7-合并分支"><a href="#7-合并分支" class="headerlink" title="7.合并分支"></a>7.合并分支</h4><p>正常合并：切换到主分支-&gt;点击右下角-&gt;选择需要合并的分支-&gt;Merge<br>冲突合并：切换到主分支-&gt;点击右下角-&gt;选择需要合并的分支-&gt;Merge-&gt;解决冲突</p><h3 id="8-IDEA集成Github"><a href="#8-IDEA集成Github" class="headerlink" title="8.IDEA集成Github"></a>8.IDEA集成Github</h3><p>查看是否有GitHub插件<br>File -&gt; Setting -&gt;Version Control-&gt;GitHub<br>如果没有在Settings-&gt;Plugings下搜索下载</p><h4 id="1-设置账号"><a href="#1-设置账号" class="headerlink" title="1.设置账号"></a>1.设置账号</h4><p>使用账号密码登录，由于网络原因难以登录。所以选择使用口令登录。</p><h4 id="2-分享工程到远程库"><a href="#2-分享工程到远程库" class="headerlink" title="2.分享工程到远程库"></a>2.分享工程到远程库</h4><p>VCS-&gt;Import into Version Contral-&gt;Share Project on GitHub</p><h4 id="3-push本地库到远程库"><a href="#3-push本地库到远程库" class="headerlink" title="3.push本地库到远程库"></a>3.push本地库到远程库</h4><p>第一种：右键项目-&gt;Git-&gt;Repository-&gt;Push<br>第二种：VCS-&gt;Git-&gt;Push<br>修改https为ssh：右键别名-&gt;Define Remote-&gt;填入ssh链接</p><h4 id="4-pull拉取远程库到本地库"><a href="#4-pull拉取远程库到本地库" class="headerlink" title="4.pull拉取远程库到本地库"></a>4.pull拉取远程库到本地库</h4><p>push要想成功一定要保证本地库版本比远程库高。因此，在push之前一定要pull一下<br>第一种：右键项目-&gt;Git-&gt;Repository-&gt;Pull<br>第二种：VCS -&gt; Git -&gt; Pull</p><h4 id="5-clone克隆远程库到本地库"><a href="#5-clone克隆远程库到本地库" class="headerlink" title="5.clone克隆远程库到本地库"></a>5.clone克隆远程库到本地库</h4><p>初始化页面-&gt;Get from Version Contral</p><h3 id="9-IDEA集成码云"><a href="#9-IDEA集成码云" class="headerlink" title="9.IDEA集成码云"></a>9.IDEA集成码云</h3><h4 id="1-IDEA安装码云（Gitee）的插件"><a href="#1-IDEA安装码云（Gitee）的插件" class="headerlink" title="1.IDEA安装码云（Gitee）的插件"></a>1.IDEA安装码云（Gitee）的插件</h4><p>File -&gt; Settings -&gt; Plugins -&gt; 搜索Gitee-&gt;安装重启</p><h4 id="2-IDEA连接Gitee"><a href="#2-IDEA连接Gitee" class="headerlink" title="2.IDEA连接Gitee"></a>2.IDEA连接Gitee</h4><p>File -&gt; Settings -&gt; Version Contral -&gt;Gitee -&gt;登陆账号 </p><h4 id="3-分享项目到Gitee-相当于新建远程库"><a href="#3-分享项目到Gitee-相当于新建远程库" class="headerlink" title="3.分享项目到Gitee(相当于新建远程库)"></a>3.分享项目到Gitee(相当于新建远程库)</h4><p>VCS -&gt; Import into Version Contral -&gt; Share Project on Gitee</p><h4 id="4-push本地代码到远程库"><a href="#4-push本地代码到远程库" class="headerlink" title="4.push本地代码到远程库"></a>4.push本地代码到远程库</h4><p>第一种：项目文件夹右键-&gt;Git -&gt;Repository -&gt;Push<br>第二种：VCS -&gt; Git -&gt; Push<br>注意：但是第一次会有一个origin的默认链接，需要自己定义自己的连接。</p><h4 id="5-Pull远程库到本地库"><a href="#5-Pull远程库到本地库" class="headerlink" title="5.Pull远程库到本地库"></a>5.Pull远程库到本地库</h4><p>VCS -&gt; Git -&gt; Pull -&gt;选择Gitee的链接-&gt;勾选master的分支</p><h4 id="6-从Github上导入项目到Gitee"><a href="#6-从Github上导入项目到Gitee" class="headerlink" title="6.从Github上导入项目到Gitee"></a>6.从Github上导入项目到Gitee</h4><h3 id="10-GitLab"><a href="#10-GitLab" class="headerlink" title="10.GitLab"></a>10.GitLab</h3><p>简介：GitLab是由GitLabInc开发，使用MIT许可证的基于网络的Git仓库管理工具，且具有wiki和issue追踪功能。使用Git作为代码管理工具，并在此基础上搭建起来的Web服务。</p><p>官网地址：<a href="https://about.gitlab.com/">https://about.gitlab.com/</a><br>安装说明：<a href="https://about.gitlab.com/installation/">https://about.gitlab.com/installation/</a></p><h4 id="1-准备一台服务器"><a href="#1-准备一台服务器" class="headerlink" title="1.准备一台服务器"></a>1.准备一台服务器</h4><p>查看IP地址：ifconfig<br>修改ip地址：vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33   将IPADDR修改<br>修改主机名：vim &#x2F;etc&#x2F;hostsname<br>关闭服务器的网络防火墙<br>重启</p><p>配置windows的host文件的映射：eg:192.168.6.200 gitlab-server<br>配置Xshell链接</p><h4 id="2-准备gitlab-ce安装包（几百MB）"><a href="#2-准备gitlab-ce安装包（几百MB）" class="headerlink" title="2.准备gitlab-ce安装包（几百MB）"></a>2.准备gitlab-ce安装包（几百MB）</h4><p>Yum在线安装gitlab-ce时，需要下载几百MB的安装文件，非常耗时，所以最好提前将所需RPM包下载到本地，使用离线rpm的方式安装。然后将下载的安装包放在服务器的opt&#x2F;module文件夹里</p><h4 id="3-安装gitlab"><a href="#3-安装gitlab" class="headerlink" title="3.安装gitlab"></a>3.安装gitlab</h4><pre class="line-numbers language-none"><code class="language-none">sudo rpm -ivh &#x2F;opt&#x2F;module&#x2F;gitlab...sudo yum install -y curl policycoreutils-python openssh-server croniesudo lokkit -s http -s sshsudo yum install -y postfixsudo service postfix startsudo chkconfig postfix oncurl https:&#x2F;&#x2F;packages.gitlab.com&#x2F;install&#x2F;repositories&#x2F;gitlab&#x2F;gitlab-ce&#x2F;script.rpm.shsudo EXTERNAL_URL&#x3D;&quot;http:&#x2F;&#x2F;gitlab.example.com&quot; yum -y install gitlab-ce<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-初始化GitLab服务"><a href="#4-初始化GitLab服务" class="headerlink" title="4.初始化GitLab服务"></a>4.初始化GitLab服务</h4><p>gitlab-ctl reconfigure</p><h4 id="5-启动GitLab服务"><a href="#5-启动GitLab服务" class="headerlink" title="5.启动GitLab服务"></a>5.启动GitLab服务</h4><p>gitlab-ctl start</p><h4 id="6-登录GitLab创建远程库"><a href="#6-登录GitLab创建远程库" class="headerlink" title="6.登录GitLab创建远程库"></a>6.登录GitLab创建远程库</h4><h4 id="7-IDEA集成GitLab"><a href="#7-IDEA集成GitLab" class="headerlink" title="7.IDEA集成GitLab"></a>7.IDEA集成GitLab</h4><p>与Gitee操作一样</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>素数筛</title>
      <link href="/2022/03/17/primesieve/"/>
      <url>/2022/03/17/primesieve/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是素数"><a href="#1-什么是素数" class="headerlink" title="1.什么是素数"></a>1.什么是素数</h3><blockquote><p>质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数（规定1既不是质数也不是合数）。</p></blockquote><h3 id="2-什么是素数筛"><a href="#2-什么是素数筛" class="headerlink" title="2.什么是素数筛"></a>2.什么是素数筛</h3><blockquote><p><strong>素数筛法</strong>，是一种快速“筛”出2~n之间所有素数的方法。</p></blockquote><h3 id="3-常用的素数筛"><a href="#3-常用的素数筛" class="headerlink" title="3.常用的素数筛"></a>3.常用的素数筛</h3><p>1.直接筛法（时间复杂度O(n*sqrt(n)）)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> prime<span class="token punctuation">[</span><span class="token number">200000</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//prime是存储素数的数组，count是数组里面素数的个数</span><span class="token keyword">void</span> <span class="token function">getPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    prime<span class="token punctuation">[</span><span class="token operator">++</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">//2肯定是素数</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment">//素数肯定是奇数,所以i = i+2</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//判断i是不是素数标记</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>j<span class="token operator">*</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">//判断i是不是还有其他因数</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">//如果i还有其他因数，则不是素数</span>            <span class="token punctuation">&#123;</span>                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//标志i不是素数</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>     <span class="token comment">//退出对i判断的循环</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//如果执行了上面代码flag还是0，说明i就是素数</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> prime<span class="token punctuation">[</span>c<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.埃氏筛（时间复杂度O(nlog(logn)）)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool isPrime<span class="token punctuation">[</span><span class="token number">20000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">getPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>  <span class="token comment">//假设2-n都是素数</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">//遍历2-n里面所有数</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token comment">//如果i是素数</span>            <span class="token comment">//i是素数的话，那么i的倍数肯定就不是素数</span>            <span class="token comment">//即 i*2，i*3 .....i*j肯定不是素数，注意边界i*j&lt;=n</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">*</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token comment">//n以内，且是i的倍数的数肯定不是素数，设为false</span>                isPrime<span class="token punctuation">[</span>i<span class="token operator">*</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.欧拉筛&#x2F;线性筛（时间复杂度O(n)）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> prime<span class="token punctuation">[</span><span class="token number">20000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>bool isVisit<span class="token punctuation">[</span><span class="token number">20000</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//默认都是false</span><span class="token keyword">void</span> <span class="token function">EulerSevie</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token comment">//老规矩，遍历区间</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>isVisit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> false<span class="token punctuation">)</span> <span class="token comment">//如果这个数未被访问，则是素数</span>            prime<span class="token punctuation">[</span><span class="token operator">++</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>     <span class="token comment">//将素数保存在素数数组里面，计数+1</span>        <span class="token comment">//下面for循环及里面的语句才是这个算法的精髓，我们下面细讲</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            isVisit<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(一)递归与分治策略</title>
      <link href="/2022/03/15/recursionanddivideandconquerstrategy/"/>
      <url>/2022/03/15/recursionanddivideandconquerstrategy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>分治法的基本思想是：将一个难以解决的大问题分割成一些规模较小的相同问题，以便各个击破，即分而治之。由分治法产生的子问题往往是原问题的较小模式，子问题与原问题类型一致而其规模不断缩小。由此自然引出递归算法。</p></blockquote><h3 id="递归的概念："><a href="#递归的概念：" class="headerlink" title="递归的概念："></a>递归的概念：</h3><blockquote><p>直接或者间接调用自身的算法称为递归算法。用函数自身给出定义的函数称为递归函数。</p></blockquote><p><strong>可以使用递归求解的问题：</strong></p><ol><li>阶乘函数</li><li>Fibonacci数列</li><li>Ackerman函数</li><li>排列问题</li><li>整数划分问题</li><li>Hanoi塔问题</li></ol><h3 id="分治法的基本思想："><a href="#分治法的基本思想：" class="headerlink" title="分治法的基本思想："></a>分治法的基本思想：</h3><blockquote><p>分治法的基本思想是将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同，递归的解这些子问题，然后将各个子问题的解合并得到原问题的解。</p></blockquote><h3 id="1-二分搜索问题"><a href="#1-二分搜索问题" class="headerlink" title="1.二分搜索问题"></a>1.二分搜索问题</h3><p>给定<strong>排好序</strong>的n个元素a[0:n-1]，现在要在这n个元素中找到一个特定元素x;该题可以用顺序查找算法做，但是顺序查找算法没有利用该数组有序的条件。他的时间复杂度为O(n);而二分搜索方法充分利用了元素间的次序关系。</p><p><strong>二分搜索的复杂度：</strong><br>时间复杂度：O(logn)<br>空间复杂度：O(1)</p><p><strong>二分搜索算法的基本思想：</strong>将n个元素分成个数大致相同的两半，取a[n&#x2F;2]与x作比较。如果x&#x3D;a[n&#x2F;2]，则找到x，算法终止；如果x&lt;a[n&#x2F;2]，则只在数组a的左半部分继续搜索x；如果x&gt;a[n&#x2F;2]，则只在数组a的右半部继续搜索x。例子(LeetCode-704.二分查找)如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>mid<span class="token punctuation">;</span>        left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-大整数的乘法"><a href="#2-大整数的乘法" class="headerlink" title="2.大整数的乘法"></a>2.大整数的乘法</h3><p>现有两个大整数X和Y都是n位的十进制数，计算他们的乘积XY。</p><p>将这两个大整数都分成两段，每段长为n&#x2F;2，如下图示意：</p><p><img src="https://img-blog.csdnimg.cn/20201129001414493.png"></p><p>即：<strong>X&#x3D;A*10^(n&#x2F;2)+B，Y&#x3D;C*10^(n&#x2F;2)+D</strong>，则：<br>$$<br>\begin{equation}\begin{split}<br>XY&amp;&#x3D;(A\times 10^{\frac n 2} + B)(C \times 10^{\frac n 2} + D)\\<br>&amp;&#x3D;AC \times 10^{\frac n 2} + (AD + BC) \times 10^{n} + BD<br>\end{split}\end{equation}<br>$$</p><p>该公式需要进行4次n&#x2F;2位整数的乘法（AC,AD,BC,BD）,3次不超过2n位的整数加法，以及两次移位。但可以<strong>优化为以下公式</strong>：<br>$$<br>XY &#x3D; AC \times 10^{n} + ((A-B)(D-C)+AC+BD) \times 10^{\frac n 2} + BD<br>$$<br>优化后的公式只需要进行3次n&#x2F;2位整数的乘法,6次的整数加法，以及两次移位。设T(n)是2个n位整数相乘所需要的运算总数，则：</p><p>$$<br>T(n) &#x3D;<br>\begin{cases}<br>1 &amp; n&#x3D;1\\<br>3T(n&#x2F;2) + cn &amp; n&gt;1<br>\end{cases}<br>$$</p><p>$$<br>\text{时间复杂度：}<br>T(n) &#x3D; O(n^{log3}) &#x3D; O(n^{1.59})<br>$$</p><p>递归推导：已知<strong>T(1)&#x3D;1,T(n)&#x3D;3T(n&#x2F;2)+cn</strong><br>$$<br>\begin{equation}\begin{split}<br>T(n) &amp;&#x3D; 3T(\frac n 2) + cn\\<br>&amp;&#x3D;3(3T(\frac n 4) + \frac {cn} 2) + cn\\<br>&amp;&#x3D;9(T(\frac n 8) + \frac {cn} 4) + \frac {3cn} 2 + cn\\<br>&amp;&#x3D;\text{……}\\<br>&amp;&#x3D;3^k + 3^{k-1} \times 2c + 3^{k-2} \times 4c + \text{……}+3c2^{k-1} + c2^{k}\\<br>&amp;&#x3D;O(n^{log3})\\<br>&amp;&#x3D;O(n^{1.59})<br>\end{split}\end{equation}<br>$$</p><h3 id="3-Strassen矩阵乘法"><a href="#3-Strassen矩阵乘法" class="headerlink" title="3.Strassen矩阵乘法"></a>3.Strassen矩阵乘法</h3><blockquote><p>设A和B是两个 n*n的矩阵，他们的乘积同样是一个n*n的矩阵。A和B的乘积矩阵C中的元素 $ c_{ij} $定义为:<br>$$<br>c_{ij}&#x3D;\sum_{k&#x3D;1}^{n}a_{ik}b_{kj}<br>$$</p></blockquote><p>如果按照定义中的方法来计算所需要的计算时间是$ O(n^3) $，但是如果采用分治的方法可以将时间复杂度改进到$ O(n^{log_{7}}) &#x3D; O(n^{2.81}) $。其基本思想还是使用分治法。</p><p><strong>具体思想方法：</strong></p><p>将A,B,C三个矩阵每个都分为四个子矩阵，则C&#x3D;AB可以重写为：<br>$$<br>\begin{bmatrix}<br>C_{11} &amp; C_{12}\\<br>C_{21} &amp; C_{22}\\<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>A_{11} &amp; A_{12}\\<br>A_{21} &amp; A_{22}\\<br>\end{bmatrix}<br>\begin{bmatrix}<br>B_{11} &amp; B_{12}\\<br>B_{21} &amp; B_{22}\\<br>\end{bmatrix}<br>$$</p><p>由此可得：<br>$$<br>C_{11}  &#x3D; A_{11} \times B_{11} + A_{12} \times B_{21}\\<br>C_{12}  &#x3D; A_{11} \times B_{12} + A_{12} \times B_{22}\\<br>C_{21}  &#x3D; A_{21} \times B_{11} + A_{22} \times B_{21}\\<br>C_{22}  &#x3D; A_{21} \times B_{12} + A_{22} \times B_{22}\\<br>$$<br>如果n&#x3D;2，则2个2阶方程方阵的乘积可以直接算出来，共需8次乘法和4次加法。当子矩阵的阶数大于2时，为求2个子矩阵的积，可以将子矩阵继续分块，直到子矩阵的阶降为2。由此产生了分治降阶的递归算法。依次算法，计算2个n阶方阵的乘积转化为计算8个n&#x2F;2阶方阵的乘积和4个n&#x2F;2阶方阵的加法。2个n&#x2F;2<em>n&#x2F;2矩阵的加法显然可以在$ O(n^{2}) $时间内完成。因此T(n)的递归方程如下：<br>$$<br>T(n) &#x3D;<br>\begin{cases}<br>O(1) &amp; n &#x3D; 2\\<br>8T(n&#x2F;2) + O(n^{2}) &amp; n &gt; 2<br>\end{cases}<br>$$<br>这个方程的解依旧是$ O(n^3) $，但是在该基础上</em><strong>Strassen</strong><em>提出了一种新的算法来计算2个2阶方程的乘积。</em><strong>这个算法只用了7次乘法运算</strong>*，但增加了加减法的运算次数，这7次乘法是：<br>$$<br>M_1 &#x3D; A_{11}(B_{12} \times B_{22})\\<br>M_2 &#x3D; (A_{11} + A_{12})B_{22}\\<br>M_3 &#x3D; (A_{21} + A_{22})B_{11}\\<br>M_4 &#x3D; A_{22}(B_{21} - B_{11})\\<br>M_5 &#x3D; (A_{11} + A_{22})(B_{11} + B_{22})\\<br>M_6 &#x3D; (A_{12} - A_{22})(B_{21} + B_{22})\\<br>M_7 &#x3D; (A_{11} - A_{21})(B_{11} + B_{12})<br>$$<br>做了这7次乘法后，在做若干次加减法，就可以得到：<br>$$<br>C_{11} &#x3D; M_5 + M_4 - M_2 + M_6\\<br>C_{12} &#x3D; M_1 +M_2\\<br>C_{21} &#x3D; M_3 + M_5\\<br>C_{22} &#x3D; M_5 + M_1 - M_3 - M_7<br>$$<br>Strassen矩阵乘法中用了7次对于n&#x2F;2阶矩阵乘积的递归调用和18次n&#x2F;2阶矩阵的加减运算。由此可知，<strong>Strassen算法的时间复杂度T(n)为</strong>：<br>$$<br>T(n) &#x3D;<br>\begin{cases}<br>O(1) &amp; n &#x3D; 2\\<br>7T(n&#x2F;2) + O(n^2) &amp; n&gt;2<br>\end{cases}<br>$$<br>由此解递归方程得$ T(n) &#x3D; O(n^{log7}) &#x3D; O(n^{2.81}) $</p><h3 id="4-棋盘覆盖"><a href="#4-棋盘覆盖" class="headerlink" title="4.棋盘覆盖"></a>4.棋盘覆盖</h3><h4 id="1-什么是棋盘覆盖"><a href="#1-什么是棋盘覆盖" class="headerlink" title="1.什么是棋盘覆盖"></a>1.什么是棋盘覆盖</h4><p><strong>首先需要引入两个概念：什么是特殊方格？什么是特殊棋盘？</strong><br>在一个$ 2^k \times 2^k $个方格组成的期盼中，若恰有一个方格与其他方格不同，则称该方格为特殊方格，且该棋盘为特殊棋盘。</p><p><strong>然后再引出棋盘覆盖问题：</strong><br>在棋盘覆盖问题中，要用如下图所示的4种形态不同的L型骨牌覆盖一个给定的特殊棋盘上除特殊方格以外的其他方格，且任何两个L型骨牌不可相互重叠。除此以外，我们容易知道，覆盖一个特殊棋盘需要用到$ (4^k - 1)&#x2F;3 $个骨牌数。<br><img src="https://img-blog.csdnimg.cn/20200707141724222.png"><img src="https://img-blog.csdnimg.cn/20200707141821358.png"></p><h4 id="2-解决棋盘覆盖的思想方法"><a href="#2-解决棋盘覆盖的思想方法" class="headerlink" title="2.解决棋盘覆盖的思想方法"></a>2.解决棋盘覆盖的思想方法</h4><p>用分治策略，可以设计解棋盘覆盖问题的一个简便的算法。当k&gt;0时，将$ 2^k \times 2^k  $棋盘分割为4个$ 2^{k-1} \times 2^{k-1} $子棋盘。如图所示(a)，特殊方格必位于4个较小子棋盘之一中，其余三个子棋盘中无特殊方格。为了将这三个无特殊方格的子棋盘转化为特殊棋盘，可以用一个L型骨牌覆盖这三个较小棋盘的会和处，如图(b)所示，这三个子棋盘上被L型骨牌覆盖的方格就成为该棋盘上的特殊方格，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归的使用这种份分割，直至棋盘转化为$ 1 \times 1$棋盘。<br><img src="https://img-blog.csdnimg.cn/20200707145142306.png"></p><h4 id="3-棋盘覆盖的代码"><a href="#3-棋盘覆盖的代码" class="headerlink" title="3.棋盘覆盖的代码"></a>3.棋盘覆盖的代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token class-name">ChessBoard</span><span class="token punctuation">(</span><span class="token keyword">int</span> tr<span class="token punctuation">,</span><span class="token keyword">int</span> tc<span class="token punctuation">,</span><span class="token keyword">int</span> dr<span class="token punctuation">,</span><span class="token keyword">int</span> dc<span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token keyword">int</span> t <span class="token operator">=</span> tile<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">int</span> s <span class="token operator">=</span> size<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//覆盖左上角子棋盘</span><span class="token keyword">if</span><span class="token punctuation">(</span>dr <span class="token operator">&lt;</span> tr <span class="token operator">+</span> s <span class="token operator">&amp;&amp;</span> dc <span class="token operator">&lt;</span> tc <span class="token operator">+</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token punctuation">,</span> tc<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>board<span class="token punctuation">[</span>tr<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>tc<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token punctuation">,</span> tc<span class="token punctuation">,</span> tr<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//覆盖右上角子棋盘</span><span class="token keyword">if</span><span class="token punctuation">(</span>dr <span class="token operator">&lt;</span> tr <span class="token operator">+</span> s <span class="token operator">&amp;&amp;</span> dc <span class="token operator">>=</span> tc <span class="token operator">+</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>board<span class="token punctuation">[</span>tr<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>tc<span class="token operator">+</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token punctuation">,</span> tr<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//覆盖左下角棋盘</span><span class="token keyword">if</span><span class="token punctuation">(</span>dr <span class="token operator">>=</span> tr<span class="token operator">+</span>s <span class="token operator">&amp;&amp;</span> dc <span class="token operator">&lt;</span> tc<span class="token operator">+</span>s <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token operator">+</span>s<span class="token punctuation">,</span> tc<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>board<span class="token punctuation">[</span>tr<span class="token operator">+</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>tc<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token operator">+</span>s<span class="token punctuation">,</span> tc<span class="token punctuation">,</span> tr<span class="token operator">+</span>s<span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//覆盖右下角</span><span class="token keyword">if</span><span class="token punctuation">(</span>dr <span class="token operator">>=</span> tr<span class="token operator">+</span>s <span class="token operator">&amp;&amp;</span> dc <span class="token operator">>=</span> tc<span class="token operator">+</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token operator">+</span>s<span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>board<span class="token punctuation">[</span>tr<span class="token operator">+</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>tc<span class="token operator">+</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token operator">+</span>s<span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token punctuation">,</span> tr<span class="token operator">+</span>s<span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* * Board:表示棋盘 * tile:全局变量表示L型骨牌的编号，其初始值为0 * tr:棋盘左上角方格的行数 * tc:棋盘左上角方格的列数 * dr:特殊方格所在的行号 * dc:特殊方格所在的列号 * size:size=2^k,棋盘规格为2^k * 2^k */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-分治法解决棋盘覆盖的复杂度"><a href="#4-分治法解决棋盘覆盖的复杂度" class="headerlink" title="4.分治法解决棋盘覆盖的复杂度"></a>4.分治法解决棋盘覆盖的复杂度</h4><p>分治法的得出的时间复杂度T(n)的递归方程是：<br>$$<br>T(n)<br>\begin{cases}<br>&#x3D;O(1) &amp; k&#x3D;0\\<br>&#x3D;4T(k-1) + O(1) &amp; k &gt; 0<br>\end{cases}<br>$$<br>解递归方程得$ T(n) &#x3D; O(4^k) $</p><h3 id="5-合并排序"><a href="#5-合并排序" class="headerlink" title="5.合并排序"></a>5.合并排序</h3><h4 id="1-合并排序的基本思想"><a href="#1-合并排序的基本思想" class="headerlink" title="1.合并排序的基本思想"></a>1.合并排序的基本思想</h4><p>合并排序是用分治法实现对n个元素排序的算法。其基本思想是：将待排序元素分成大小大致相同的两个子集合，如果子集合中的元素个数为1，则返回，否则对这两个集合继续进行合并排序，排好序后用一个合并函数将两个子集合合并即可。</p><h4 id="2-合并排序的代码"><a href="#2-合并排序的代码" class="headerlink" title="2.合并排序的代码"></a>2.合并排序的代码</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//递归形式的合并排序</span><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>    <span class="token comment">//数组中只有一个元素</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token comment">//数组中有多个元素</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left0 <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> k <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            b<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            b<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">></span> mid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>k <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            b<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">></span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            b<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        a<span class="token punctuation">[</span>left0<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-Master定理"><a href="#3-Master定理" class="headerlink" title="3.Master定理"></a>3.Master定理</h4><p>$$<br>\text{在递推式}<br>T(n)&#x3D;kT(n&#x2F;m)+f(n)<br>\text{中,}<br>f(n) &#x3D; n^{d}<br>\text{,}<br>d \ge 0<br>\text{,则}\\<br>T(n) &#x3D;<br>\begin{cases}<br>O(n^{d}) &amp; k &lt; m^{d}\\<br>O(n^{d}log_{m}n) &amp; k &#x3D; m^{d}\\<br>O(n^{log_{m}k}) &amp; k &gt; m^{d}<br>\end{cases}<br>$$</p><h4 id="4-合并排序的时间复杂度"><a href="#4-合并排序的时间复杂度" class="headerlink" title="4.合并排序的时间复杂度"></a>4.合并排序的时间复杂度</h4><p><strong>合并排序算法的时间复杂度T(n)的递归方程为：</strong><br>$$<br>T(n)<br>\begin{cases}<br>O(1) &amp; n \le 1 \\<br>2T(n&#x2F;2)+O(n) &amp; n \gt 1<br>\end{cases}<br>$$<br>根据master解得**T(n)&#x3D;O(nlogn)**。</p><p>由于排序问题的渐进时间下界为O(nlogn)，所以<strong>合并算法是一个渐进最优算法</strong>。</p><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h3><h4 id="1-快速排序的基本思想"><a href="#1-快速排序的基本思想" class="headerlink" title="1.快速排序的基本思想"></a>1.快速排序的基本思想</h4><p>快速排序算法是基于分治策略的排序算法。其基本思想是对输入的子数组a[p:r]，按以下三个步骤进行排序。</p><p>1.分解：以a[p]为基准元素将a[p:r],分成三段a[p:q-1],a[q],a[q+1,r]，使得a[p:q-1]中的元素都小于a[q],同时a[q+1:r]中的元素都大于a[q],下标是划分后一开始a[p]的值对应的下标。</p><p>2.递归求解：递归调用快速排序算法，对a[p,q-1]和a[q+1;r]求解</p><p>3.合并：因为排序是就地进行的，所以排好序后不需要进行任何计算，a[p:r]就已经排好序了.</p><h4 id="2-快速排序的代码"><a href="#2-快速排序的代码" class="headerlink" title="2.快速排序的代码"></a>2.快速排序的代码</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">quickSqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> q<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>p<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSqrt</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>p<span class="token punctuation">,</span><span class="token punctuation">(</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSqrt</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token punctuation">(</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> p<span class="token punctuation">,</span> j <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> a<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> x<span class="token punctuation">)</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-快速排序的时间复杂度"><a href="#3-快速排序的时间复杂度" class="headerlink" title="3.快速排序的时间复杂度"></a>3.快速排序的时间复杂度</h4><p>快速排序算法的时间复杂度的递归方程为：<br>$$<br>\text{在最坏情况下}\\<br>T(n)&#x3D;<br>\begin{cases}<br>O(1) &amp; n \le 1 \\<br>T(n-1) + O(n) &amp; n \gt 1<br>\end{cases}\\<br>\text{解递归方程得：}T(n) &#x3D; O(n^{2})\\<br>\text{在最好情况下}\\<br>T(n)&#x3D;<br>\begin{cases}<br>O(1) &amp; n \le 1 \\<br>T(n&#x2F;2) + O(n) &amp; n \gt 1<br>\end{cases}\\<br>\text{解递归方程得：}T(n) &#x3D; O(nlogn)<br>$$<br>可以证明<strong>快速排序在平均情况下得时间复杂度也为T(n)&#x3D;O(nlogn);</strong></p><p>快速排序得时间复杂度取决于划分的对称性，可以随机选择基准数，从而可以期望划分是比较对称的。</p><h3 id="7-循环赛日程表"><a href="#7-循环赛日程表" class="headerlink" title="7.循环赛日程表"></a>7.循环赛日程表</h3><h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h4><p>设有n&#x3D;2k个运动员要进行网球循环赛。现要设计一个满足以下要求的比赛日程表：</p><ol><li>每个选手必须与其他n-1个选手各赛一次；</li><li>每个选手一天只能参赛一次；</li><li>循环赛在n-1天内结束。<br>按此要求可将比赛日程表设计成有n行和(n-1)列的表。在表中第i行和第j列处填入第i个选手在第j天所遇到的选手。</li></ol><h4 id="2-分治策略算法的基本思想"><a href="#2-分治策略算法的基本思想" class="headerlink" title="2.分治策略算法的基本思想"></a>2.分治策略算法的基本思想</h4><p>如图，所列出的正方形表是8个选手的比赛日程表。其中左上角与左下角的两小块分别为选手 1 至选手 4 和选手 5 至选手 8 前3天的比赛日程。据此，将左上角小块中的所有数字按其相对位置抄到右下角，又将左下角小块中的所有数字按其相对位置抄到右上角，这样我们就分别安排好了选手1至选手4和选手5至选手8在后4天的比赛日程。依此思想容易将这个比赛日程表推广到具有任意多个选手的情形。</p><p>$$<br>\begin{matrix}<br>1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 \\<br>2 &amp; 1 &amp; 4 &amp; 3 &amp; 6 &amp; 5 &amp; 8 &amp; 7 \\<br>3 &amp; 4 &amp; 1 &amp; 2 &amp; 7 &amp; 8 &amp; 5 &amp; 6 \\<br>4 &amp; 3 &amp; 2 &amp; 1 &amp; 8 &amp; 7 &amp; 6 &amp; 5 \\<br>5 &amp; 6 &amp; 7 &amp; 8 &amp; 1 &amp; 2 &amp; 3 &amp; 4\\<br>6 &amp; 5 &amp; 8 &amp; 7 &amp; 2 &amp; 1 &amp; 4 &amp; 3\\<br>7 &amp; 8 &amp; 5 &amp; 6 &amp; 3 &amp; 4 &amp; 1 &amp; 2\\<br>8 &amp; 7 &amp; 6 &amp; 5 &amp; 4 &amp; 3 &amp; 2 &amp; 1\\<br>\end{matrix}<br>$$<br>3.核心代码</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void schedule(int k, int n, int** array)   &#x2F;&#x2F; 数组下标从1开始&#123;    for (int i &#x3D; 1;i &lt;&#x3D; n;i++)  &#x2F;&#x2F; 第一行排1-n        array[1][i] &#x3D; i;        int m &#x3D; 1;  &#x2F;&#x2F; 用来控制每一次填表时i行j列的起始填充位置        for (int s &#x3D; 1;s &lt;&#x3D; k;s++)  &#x2F;&#x2F; k指分成k大部分进行填充日程表；s指第几大部分    &#123;        n &#x3D; n &#x2F; 2;        for (int t &#x3D; 1;t &lt;&#x3D; n;t++)  &#x2F;&#x2F; 第s部分内的循环        &#123;            for (int i &#x3D; m + 1;i &lt;&#x3D; 2 * m;i++) &#x2F;&#x2F; 行            &#123;                for (int j &#x3D; m + 1;j &lt;&#x3D; 2 * m;j++) &#x2F;&#x2F; 列                &#123;                    array[i][j + (t - 1) * m * 2] &#x3D; array[i - m][j + (t - 1) * m * 2 - m];       &#x2F;&#x2F;左上角等于右下角的值                    array[i][j + (t - 1) * m * 2 - m] &#x3D; array[i - m][j + (t - 1) * m * 2];       &#x2F;&#x2F;左下角等于右上角的值                &#125;            &#125;        &#125;        m *&#x3D; 2;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法设计与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Hexo博客并且部署到GitHub</title>
      <link href="/2022/03/09/hexo-hithub/"/>
      <url>/2022/03/09/hexo-hithub/</url>
      
        <content type="html"><![CDATA[<h3 id="一，下载Nodejs-git-hexo"><a href="#一，下载Nodejs-git-hexo" class="headerlink" title="一，下载Nodejs,git,hexo"></a>一，下载Nodejs,git,hexo</h3><ol><li><p>Nodejs下载网址：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p><p>检查是否安装成功：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">node -vnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li><p>git下载网址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>检查是否安装成功：<code>git --version</code></p></li><li><p>hexo下载：<code>npm install hexo-cli -g</code><br>检查是否安装成功：<code>hexo -v</code></p></li></ol><h3 id="二，搭建仓库"><a href="#二，搭建仓库" class="headerlink" title="二，搭建仓库"></a>二，搭建仓库</h3><ol><li><p>github注册账号</p></li><li><p>新建仓库</p><p>​    Repository名称：用户名.github.io</p><p>​    权限：public</p><p>​    勾选：ADD a README file</p></li></ol><h3 id="三，生成ssh密钥并绑定："><a href="#三，生成ssh密钥并绑定：" class="headerlink" title="三，生成ssh密钥并绑定："></a>三，生成ssh密钥并绑定：</h3><ol><li><p>生成ssh密钥：<code>ssh-keygen -t rsa -C &quot;GitHub邮箱地址&quot;</code></p></li><li><p>在用户文件夹下的.ssh文件夹下找到公钥：id_rsa.pub</p></li><li><p>将公钥复制填写到你的GitHub上绑定</p></li><li><p>检测ssh密钥是否绑定成功：ssh -T <a href="mailto:&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;">&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;</a></p></li></ol><h3 id="四，搭建本地博客"><a href="#四，搭建本地博客" class="headerlink" title="四，搭建本地博客"></a>四，搭建本地博客</h3><ol><li><p>新建一个文件夹blog</p></li><li><p>在该文件夹里初始化hexo博客： hexo init</p></li><li><p>在本地部署服务器查看 hexo s</p></li></ol><h3 id="五，部署到github"><a href="#五，部署到github" class="headerlink" title="五，部署到github"></a>五，部署到github</h3><ol><li>将根目录下的_config.yml中最后一行修改添加为：</li></ol><pre class="line-numbers language-none"><code class="language-none">deploy: type: gitrepository: 你的仓库地址branch: main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>安装hexo-deployer-git</li></ol><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>生成静态文件</li></ol><pre class="line-numbers language-none"><code class="language-none">hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>设置邮箱和用户名</li></ol><pre class="line-numbers language-none"><code class="language-none">git config --global user.email &quot;你的邮箱&quot;git config --global user.name &quot;你的用户名&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="5"><li>将静态文件上传到GitHub</li></ol><pre class="line-numbers language-none"><code class="language-none">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意：第一次上传需要用githun生成token</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
