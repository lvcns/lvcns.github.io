<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git笔记</title>
      <link href="/2022/03/22/gitbiji/"/>
      <url>/2022/03/22/gitbiji/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Git是一个免费的开源的分布式版本控制系统。"><a href="#1-Git是一个免费的开源的分布式版本控制系统。" class="headerlink" title="1.Git是一个免费的开源的分布式版本控制系统。"></a>1.Git是一个免费的开源的分布式版本控制系统。</h3><p>Git官网：git-scm.com</p><p>版本控制的核心思想：记录文件修改历史</p><h3 id="2-GIt的工作机制"><a href="#2-GIt的工作机制" class="headerlink" title="2.GIt的工作机制"></a>2.GIt的工作机制</h3><p>分为三个部分<br>工作区git add -&gt; 暂存区 git commit-&gt; 本地库<br>写代码                 临时存储                     历史版本</p><h3 id="3-Git常用命令"><a href="#3-Git常用命令" class="headerlink" title="3.Git常用命令"></a>3.Git常用命令</h3><p>命令名称                                                          作用<br>git config –global user.name 用户名        设置用户签名<br>git config –global user.email 邮箱            设置用户签名<br>git init                                                         初始化本地库<br>git statua                                                    查看本地库状态<br>git add 文件名                                            添加到暂存区<br>git rm –cached 文件名                               将暂存区的文件删掉<br>git commit -m “日志信息” 文件名              添加到本地库<br>git reflog                                                     查看历史版本<br>git log                                                         查看详细的版本信息<br>git reset –hard 版本号                                版本穿梭</p><h3 id="4-Git分支操作"><a href="#4-Git分支操作" class="headerlink" title="4.Git分支操作"></a>4.Git分支操作</h3><p><strong>什么是分支：</strong>在版本控制中，同时推进多个任务，为每个任务，我们可以单独创建一个分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，在开发自己分支的时候，不会影响主线分支的运行。分支的底层是指针的作用。</p><p><strong>分支的操作：</strong><br>命令名称                                                          作用<br>git branch 分支名                                     创建分支<br>git branch -v                                             查看分支<br>git checkout 分支名                                  切换分支<br>git merge 分支                                          把指定的分支合并到当前分支上</p><p><strong>分支合并产生冲突：</strong><br>原因：合并分支时，两个分支在同一个文件的同一个位置有两套不同的修改。Git无法决定使用哪一个。必须认为决定新代码内容。</p><h3 id="5-Git团队协助机制"><a href="#5-Git团队协助机制" class="headerlink" title="5.Git团队协助机制"></a>5.Git团队协助机制</h3><p>团队内协作<br>push            clone           pull<br>跨团队协作<br>fork         clone       push        Pull request        merge         </p><h3 id="6-GitHub操作"><a href="#6-GitHub操作" class="headerlink" title="6.GitHub操作"></a>6.GitHub操作</h3><p><strong>1-.创建远程库</strong><br>远程库的名称最好和本地库的名称相同<br><strong>2-.创建远程仓库别名</strong><br>git remote -v 查看当前所有远程地址别名<br>git remote add 别名 远程地址<br><strong>3-.推送本地库到远程库</strong><br>git push 别名 分支<br>第一次登录会处理一个登陆凭证的东西：可以使用浏览器绑定或者使用token绑定。<br><strong>4-.克隆代码到本地库</strong><br>克隆会自动进行三个操作：1.拉取代码 2.初始化本地库 3.创建别名<br><strong>5-.邀请加入团队</strong><br>Setting -&gt; Manage access<br><strong>6-.SSH免密登录</strong><br>本地生成SSH密钥：ssh –keygen -t rsa  -C “描述”<br>私钥：id_rsa<br>公钥：id_rsa.pub</p><p>公钥填入GitHub：Settings-&gt;SSH and GPG keys-&gt;添加公钥</p><h3 id="7-IDEA集成Git"><a href="#7-IDEA集成Git" class="headerlink" title="7.IDEA集成Git"></a>7.IDEA集成Git</h3><h4 id="1-初始化配置"><a href="#1-初始化配置" class="headerlink" title="1.初始化配置"></a>1.初始化配置</h4><h5 id="1-配置Git忽略文件"><a href="#1-配置Git忽略文件" class="headerlink" title="1.配置Git忽略文件"></a>1.配置Git忽略文件</h5><p>创建忽略规则文件 xxxx.ignore(前缀随便起，建议git.ignore)<br>这个文件的存放位置哪里都行，但是便于让~&#x2F;.gitconfig文件引用，建议也放在用户家目录下<br>git.ignore文件模板内容如下：</p><pre class="line-numbers language-none"><code class="language-none"># Compiled class file*.class# Log file*.log# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp&#x2F;# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rarhs_err_pid*.classpath.project.settingstarget.idea*.iml       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在用户的家目录下配置.gitconfig</p><pre class="line-numbers language-none"><code class="language-none">[core]      excludesfile &#x3D; C:&#x2F;Users&#x2F;HUAN&#x2F;git.ingore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="2-定位git程序"><a href="#2-定位git程序" class="headerlink" title="2.定位git程序"></a>2.定位git程序</h5><p>File-&gt;Settings-&gt;VersionControl-&gt;Git</p><h4 id="2-IDEA的git库操作"><a href="#2-IDEA的git库操作" class="headerlink" title="2.IDEA的git库操作"></a>2.IDEA的git库操作</h4><h4 id="1-初始化git库"><a href="#1-初始化git库" class="headerlink" title="1.初始化git库"></a>1.初始化git库</h4><p>   VCS-&gt; Create Git Repository</p><h4 id="2-添加到暂存区"><a href="#2-添加到暂存区" class="headerlink" title="2.添加到暂存区"></a>2.添加到暂存区</h4><p>第一种方法：在要添加的文件处右键-&gt;Git-&gt;Add(快捷键Ctrl + Alt +A)<br>第二种方法：右键项目的根目录右键-&gt;Git-&gt;Add</p><h4 id="3-提交到本地库"><a href="#3-提交到本地库" class="headerlink" title="3.提交到本地库"></a>3.提交到本地库</h4><p>右键项目的根目录右键-&gt;Git-&gt;Commit Directory…</p><h4 id="4-切换版本"><a href="#4-切换版本" class="headerlink" title="4.切换版本"></a>4.切换版本</h4><p>查看版本信息：左下角git -&gt;log<br>切换版本：在log中选中版本右键-&gt;Checkout Revision …</p><h4 id="5-创建分支"><a href="#5-创建分支" class="headerlink" title="5.创建分支"></a>5.创建分支</h4><p>右键项目名称-&gt;Git-&gt;Repository-&gt;Branches…-&gt;New branch<br>                           或者<br>                   单击右下角Git:master-&gt;New branch</p><h4 id="6-切换分支"><a href="#6-切换分支" class="headerlink" title="6.切换分支"></a>6.切换分支</h4><p>单击右下角Git:hot-fix-&gt;点击你要切换的分支-&gt;Checkout</p><h4 id="7-合并分支"><a href="#7-合并分支" class="headerlink" title="7.合并分支"></a>7.合并分支</h4><p>正常合并：切换到主分支-&gt;点击右下角-&gt;选择需要合并的分支-&gt;Merge<br>冲突合并：切换到主分支-&gt;点击右下角-&gt;选择需要合并的分支-&gt;Merge-&gt;解决冲突</p><h3 id="8-IDEA集成Github"><a href="#8-IDEA集成Github" class="headerlink" title="8.IDEA集成Github"></a>8.IDEA集成Github</h3><p>查看是否有GitHub插件<br>File -&gt; Setting -&gt;Version Control-&gt;GitHub<br>如果没有在Settings-&gt;Plugings下搜索下载</p><h4 id="1-设置账号"><a href="#1-设置账号" class="headerlink" title="1.设置账号"></a>1.设置账号</h4><p>使用账号密码登录，由于网络原因难以登录。所以选择使用口令登录。</p><h4 id="2-分享工程到远程库"><a href="#2-分享工程到远程库" class="headerlink" title="2.分享工程到远程库"></a>2.分享工程到远程库</h4><p>VCS-&gt;Import into Version Contral-&gt;Share Project on GitHub</p><h4 id="3-push本地库到远程库"><a href="#3-push本地库到远程库" class="headerlink" title="3.push本地库到远程库"></a>3.push本地库到远程库</h4><p>第一种：右键项目-&gt;Git-&gt;Repository-&gt;Push<br>第二种：VCS-&gt;Git-&gt;Push<br>修改https为ssh：右键别名-&gt;Define Remote-&gt;填入ssh链接</p><h4 id="4-pull拉取远程库到本地库"><a href="#4-pull拉取远程库到本地库" class="headerlink" title="4.pull拉取远程库到本地库"></a>4.pull拉取远程库到本地库</h4><p>push要想成功一定要保证本地库版本比远程库高。因此，在push之前一定要pull一下<br>第一种：右键项目-&gt;Git-&gt;Repository-&gt;Pull<br>第二种：VCS -&gt; Git -&gt; Pull</p><h4 id="5-clone克隆远程库到本地库"><a href="#5-clone克隆远程库到本地库" class="headerlink" title="5.clone克隆远程库到本地库"></a>5.clone克隆远程库到本地库</h4><p>初始化页面-&gt;Get from Version Contral</p><h3 id="9-IDEA集成码云"><a href="#9-IDEA集成码云" class="headerlink" title="9.IDEA集成码云"></a>9.IDEA集成码云</h3><h4 id="1-IDEA安装码云（Gitee）的插件"><a href="#1-IDEA安装码云（Gitee）的插件" class="headerlink" title="1.IDEA安装码云（Gitee）的插件"></a>1.IDEA安装码云（Gitee）的插件</h4><p>File -&gt; Settings -&gt; Plugins -&gt; 搜索Gitee-&gt;安装重启</p><h4 id="2-IDEA连接Gitee"><a href="#2-IDEA连接Gitee" class="headerlink" title="2.IDEA连接Gitee"></a>2.IDEA连接Gitee</h4><p>File -&gt; Settings -&gt; Version Contral -&gt;Gitee -&gt;登陆账号 </p><h4 id="3-分享项目到Gitee-相当于新建远程库"><a href="#3-分享项目到Gitee-相当于新建远程库" class="headerlink" title="3.分享项目到Gitee(相当于新建远程库)"></a>3.分享项目到Gitee(相当于新建远程库)</h4><p>VCS -&gt; Import into Version Contral -&gt; Share Project on Gitee</p><h4 id="4-push本地代码到远程库"><a href="#4-push本地代码到远程库" class="headerlink" title="4.push本地代码到远程库"></a>4.push本地代码到远程库</h4><p>第一种：项目文件夹右键-&gt;Git -&gt;Repository -&gt;Push<br>第二种：VCS -&gt; Git -&gt; Push<br>注意：但是第一次会有一个origin的默认链接，需要自己定义自己的连接。</p><h4 id="5-Pull远程库到本地库"><a href="#5-Pull远程库到本地库" class="headerlink" title="5.Pull远程库到本地库"></a>5.Pull远程库到本地库</h4><p>VCS -&gt; Git -&gt; Pull -&gt;选择Gitee的链接-&gt;勾选master的分支</p><h4 id="6-从Github上导入项目到Gitee"><a href="#6-从Github上导入项目到Gitee" class="headerlink" title="6.从Github上导入项目到Gitee"></a>6.从Github上导入项目到Gitee</h4><h3 id="10-GitLab"><a href="#10-GitLab" class="headerlink" title="10.GitLab"></a>10.GitLab</h3><p>简介：GitLab是由GitLabInc开发，使用MIT许可证的基于网络的Git仓库管理工具，且具有wiki和issue追踪功能。使用Git作为代码管理工具，并在此基础上搭建起来的Web服务。</p><p>官网地址：<a href="https://about.gitlab.com/">https://about.gitlab.com/</a><br>安装说明：<a href="https://about.gitlab.com/installation/">https://about.gitlab.com/installation/</a></p><h4 id="1-准备一台服务器"><a href="#1-准备一台服务器" class="headerlink" title="1.准备一台服务器"></a>1.准备一台服务器</h4><p>查看IP地址：ifconfig<br>修改ip地址：vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33   将IPADDR修改<br>修改主机名：vim &#x2F;etc&#x2F;hostsname<br>关闭服务器的网络防火墙<br>重启</p><p>配置windows的host文件的映射：eg:192.168.6.200 gitlab-server<br>配置Xshell链接</p><h4 id="2-准备gitlab-ce安装包（几百MB）"><a href="#2-准备gitlab-ce安装包（几百MB）" class="headerlink" title="2.准备gitlab-ce安装包（几百MB）"></a>2.准备gitlab-ce安装包（几百MB）</h4><p>Yum在线安装gitlab-ce时，需要下载几百MB的安装文件，非常耗时，所以最好提前将所需RPM包下载到本地，使用离线rpm的方式安装。然后将下载的安装包放在服务器的opt&#x2F;module文件夹里</p><h4 id="3-安装gitlab"><a href="#3-安装gitlab" class="headerlink" title="3.安装gitlab"></a>3.安装gitlab</h4><pre class="line-numbers language-none"><code class="language-none">sudo rpm -ivh &#x2F;opt&#x2F;module&#x2F;gitlab...sudo yum install -y curl policycoreutils-python openssh-server croniesudo lokkit -s http -s sshsudo yum install -y postfixsudo service postfix startsudo chkconfig postfix oncurl https:&#x2F;&#x2F;packages.gitlab.com&#x2F;install&#x2F;repositories&#x2F;gitlab&#x2F;gitlab-ce&#x2F;script.rpm.shsudo EXTERNAL_URL&#x3D;&quot;http:&#x2F;&#x2F;gitlab.example.com&quot; yum -y install gitlab-ce<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-初始化GitLab服务"><a href="#4-初始化GitLab服务" class="headerlink" title="4.初始化GitLab服务"></a>4.初始化GitLab服务</h4><p>gitlab-ctl reconfigure</p><h4 id="5-启动GitLab服务"><a href="#5-启动GitLab服务" class="headerlink" title="5.启动GitLab服务"></a>5.启动GitLab服务</h4><p>gitlab-ctl start</p><h4 id="6-登录GitLab创建远程库"><a href="#6-登录GitLab创建远程库" class="headerlink" title="6.登录GitLab创建远程库"></a>6.登录GitLab创建远程库</h4><h4 id="7-IDEA集成GitLab"><a href="#7-IDEA集成GitLab" class="headerlink" title="7.IDEA集成GitLab"></a>7.IDEA集成GitLab</h4><p>与Gitee操作一样</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>素数筛</title>
      <link href="/2022/03/17/primesieve/"/>
      <url>/2022/03/17/primesieve/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是素数"><a href="#1-什么是素数" class="headerlink" title="1.什么是素数"></a>1.什么是素数</h3><blockquote><p>质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数（规定1既不是质数也不是合数）。</p></blockquote><h3 id="2-什么是素数筛"><a href="#2-什么是素数筛" class="headerlink" title="2.什么是素数筛"></a>2.什么是素数筛</h3><blockquote><p><strong>素数筛法</strong>，是一种快速“筛”出2~n之间所有素数的方法。</p></blockquote><h3 id="3-常用的素数筛"><a href="#3-常用的素数筛" class="headerlink" title="3.常用的素数筛"></a>3.常用的素数筛</h3><p>1.直接筛法（时间复杂度O(n*sqrt(n)）)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> prime<span class="token punctuation">[</span><span class="token number">200000</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//prime是存储素数的数组，count是数组里面素数的个数</span><span class="token keyword">void</span> <span class="token function">getPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    prime<span class="token punctuation">[</span><span class="token operator">++</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">//2肯定是素数</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment">//素数肯定是奇数,所以i = i+2</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//判断i是不是素数标记</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>j<span class="token operator">*</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">//判断i是不是还有其他因数</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">//如果i还有其他因数，则不是素数</span>            <span class="token punctuation">&#123;</span>                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//标志i不是素数</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>     <span class="token comment">//退出对i判断的循环</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//如果执行了上面代码flag还是0，说明i就是素数</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> prime<span class="token punctuation">[</span>c<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.埃氏筛（时间复杂度O(nlog(logn)）)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool isPrime<span class="token punctuation">[</span><span class="token number">20000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">getPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>  <span class="token comment">//假设2-n都是素数</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">//遍历2-n里面所有数</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token comment">//如果i是素数</span>            <span class="token comment">//i是素数的话，那么i的倍数肯定就不是素数</span>            <span class="token comment">//即 i*2，i*3 .....i*j肯定不是素数，注意边界i*j&lt;=n</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">*</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token comment">//n以内，且是i的倍数的数肯定不是素数，设为false</span>                isPrime<span class="token punctuation">[</span>i<span class="token operator">*</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.欧拉筛&#x2F;线性筛（时间复杂度O(n)）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> prime<span class="token punctuation">[</span><span class="token number">20000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>bool isVisit<span class="token punctuation">[</span><span class="token number">20000</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//默认都是false</span><span class="token keyword">void</span> <span class="token function">EulerSevie</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token comment">//老规矩，遍历区间</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>isVisit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> false<span class="token punctuation">)</span> <span class="token comment">//如果这个数未被访问，则是素数</span>            prime<span class="token punctuation">[</span><span class="token operator">++</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>     <span class="token comment">//将素数保存在素数数组里面，计数+1</span>        <span class="token comment">//下面for循环及里面的语句才是这个算法的精髓，我们下面细讲</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            isVisit<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归与分治策略</title>
      <link href="/2022/03/15/recursionanddivideandconquerstrategy/"/>
      <url>/2022/03/15/recursionanddivideandconquerstrategy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>分治法的基本思想是：将一个难以解决的大问题分割成一些规模较小的相同问题，以便各个击破，即分而治之。由分治法产生的子问题往往是原问题的较小模式，子问题与原问题类型一致而其规模不断缩小。由此自然引出递归算法。</p></blockquote><h3 id="递归的概念："><a href="#递归的概念：" class="headerlink" title="递归的概念："></a>递归的概念：</h3><blockquote><p>直接或者间接调用自身的算法称为递归算法。用函数自身给出定义的函数称为递归函数。</p></blockquote><p><strong>可以使用递归求解的问题：</strong></p><ol><li>阶乘函数</li><li>Fibonacci数列</li><li>Ackerman函数</li><li>排列问题</li><li>整数划分问题</li><li>Hanoi塔问题</li></ol><h3 id="分治法的基本思想："><a href="#分治法的基本思想：" class="headerlink" title="分治法的基本思想："></a>分治法的基本思想：</h3><blockquote><p>分治法的基本思想是将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同，递归的解这些子问题，然后将各个子问题的解合并得到原问题的解。</p></blockquote><h3 id="1-二分搜索问题"><a href="#1-二分搜索问题" class="headerlink" title="1.二分搜索问题"></a>1.二分搜索问题</h3><p>给定<strong>排好序</strong>的n个元素a[0:n-1]，现在要在这n个元素中找到一个特定元素x;该题可以用顺序查找算法做，但是顺序查找算法没有利用该数组有序的条件。他的时间复杂度为O(n);而二分搜索方法充分利用了元素间的次序关系。</p><p><strong>二分搜索的复杂度：</strong><br>时间复杂度：O(logn)<br>空间复杂度：O(1)</p><p><strong>二分搜索算法的基本思想：</strong>将n个元素分成个数大致相同的两半，取a[n&#x2F;2]与x作比较。如果x&#x3D;a[n&#x2F;2]，则找到x，算法终止；如果x&lt;a[n&#x2F;2]，则只在数组a的左半部分继续搜索x；如果x&gt;a[n&#x2F;2]，则只在数组a的右半部继续搜索x。例子(LeetCode-704.二分查找)如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>mid<span class="token punctuation">;</span>        left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-大整数的乘法"><a href="#2-大整数的乘法" class="headerlink" title="2.大整数的乘法"></a>2.大整数的乘法</h3><p>现有两个大整数X和Y都是n位的十进制数，计算他们的乘积XY。</p><p>将这两个大整数都分成两段，每段长为n&#x2F;2，如下图示意：</p><p><img src="https://img-blog.csdnimg.cn/20201129001414493.png"></p><p>即：<strong>X&#x3D;A*10^(n&#x2F;2)+B，Y&#x3D;C*10^(n&#x2F;2)+D</strong>，则：<br>$$<br>\begin{equation}\begin{split}<br>XY&amp;&#x3D;(A\times 10^{\frac n 2} + B)(C \times 10^{\frac n 2} + D)\\<br>&amp;&#x3D;AC \times 10^{\frac n 2} + (AD + BC) \times 10^{n} + BD<br>\end{split}\end{equation}<br>$$</p><p>该公式需要进行4次n&#x2F;2位整数的乘法（AC,AD,BC,BD）,3次不超过2n位的整数加法，以及两次移位。但可以<strong>优化为以下公式</strong>：<br>$$<br>XY &#x3D; AC \times 10^{n} + ((A-B)(D-C)+AC+BD) \times 10^{\frac n 2} + BD<br>$$<br>优化后的公式只需要进行3次n&#x2F;2位整数的乘法,6次的整数加法，以及两次移位。设T(n)是2个n位整数相乘所需要的运算总数，则：</p><p>$$<br>T(n) &#x3D;<br>\begin{cases}<br>1 &amp; n&#x3D;1\\<br>3T(n&#x2F;2) + cn &amp; n&gt;1<br>\end{cases}<br>$$</p><p>$$<br>\text{时间复杂度：}<br>T(n) &#x3D; O(n^{log3}) &#x3D; O(n^{1.59})<br>$$</p><p>递归推导：已知<strong>T(1)&#x3D;1,T(n)&#x3D;3T(n&#x2F;2)+cn</strong><br>$$<br>\begin{equation}\begin{split}<br>T(n) &amp;&#x3D; 3T(\frac n 2) + cn\\<br>&amp;&#x3D;3(3T(\frac n 4) + \frac {cn} 2) + cn\\<br>&amp;&#x3D;9(T(\frac n 8) + \frac {cn} 4) + \frac {3cn} 2 + cn\\<br>&amp;&#x3D;\text{……}\\<br>&amp;&#x3D;3^k + 3^{k-1} \times 2c + 3^{k-2} \times 4c + \text{……}+3c2^{k-1} + c2^{k}\\<br>&amp;&#x3D;O(n^{log3})\\<br>&amp;&#x3D;O(n^{1.59})<br>\end{split}\end{equation}<br>$$</p><h3 id="3-Strassen矩阵乘法"><a href="#3-Strassen矩阵乘法" class="headerlink" title="3.Strassen矩阵乘法"></a>3.Strassen矩阵乘法</h3><blockquote><p>设A和B是两个 n*n的矩阵，他们的乘积同样是一个n*n的矩阵。A和B的乘积矩阵C中的元素 $ c_{ij} $定义为:<br>$$<br>c_{ij}&#x3D;\sum_{k&#x3D;1}^{n}a_{ik}b_{kj}<br>$$</p></blockquote><p>如果按照定义中的方法来计算所需要的计算时间是$ O(n^3) $，但是如果采用分治的方法可以将时间复杂度改进到$ O(n^{log_{7}}) &#x3D; O(n^{2.81}) $。其基本思想还是使用分治法。</p><p><strong>具体思想方法：</strong></p><p>将A,B,C三个矩阵每个都分为四个子矩阵，则C&#x3D;AB可以重写为：<br>$$<br>\begin{bmatrix}<br>C_{11} &amp; C_{12}\\<br>C_{21} &amp; C_{22}\\<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>A_{11} &amp; A_{12}\\<br>A_{21} &amp; A_{22}\\<br>\end{bmatrix}<br>\begin{bmatrix}<br>B_{11} &amp; B_{12}\\<br>B_{21} &amp; B_{22}\\<br>\end{bmatrix}<br>$$</p><p>由此可得：<br>$$<br>C_{11}  &#x3D; A_{11} \times B_{11} + A_{12} \times B_{21}\\<br>C_{12}  &#x3D; A_{11} \times B_{12} + A_{12} \times B_{22}\\<br>C_{21}  &#x3D; A_{21} \times B_{11} + A_{22} \times B_{21}\\<br>C_{22}  &#x3D; A_{21} \times B_{12} + A_{22} \times B_{22}\\<br>$$<br>如果n&#x3D;2，则2个2阶方程方阵的乘积可以直接算出来，共需8次乘法和4次加法。当子矩阵的阶数大于2时，为求2个子矩阵的积，可以将子矩阵继续分块，直到子矩阵的阶降为2。由此产生了分治降阶的递归算法。依次算法，计算2个n阶方阵的乘积转化为计算8个n&#x2F;2阶方阵的乘积和4个n&#x2F;2阶方阵的加法。2个n&#x2F;2<em>n&#x2F;2矩阵的加法显然可以在$ O(n^{2}) $时间内完成。因此T(n)的递归方程如下：<br>$$<br>T(n) &#x3D;<br>\begin{cases}<br>O(1) &amp; n &#x3D; 2\\<br>8T(n&#x2F;2) + O(n^{2}) &amp; n &gt; 2<br>\end{cases}<br>$$<br>这个方程的解依旧是$ O(n^3) $，但是在该基础上</em><strong>Strassen</strong><em>提出了一种新的算法来计算2个2阶方程的乘积。</em><strong>这个算法只用了7次乘法运算</strong>*，但增加了加减法的运算次数，这7次乘法是：<br>$$<br>M_1 &#x3D; A_{11}(B_{12} \times B_{22})\\<br>M_2 &#x3D; (A_{11} + A_{12})B_{22}\\<br>M_3 &#x3D; (A_{21} + A_{22})B_{11}\\<br>M_4 &#x3D; A_{22}(B_{21} - B_{11})\\<br>M_5 &#x3D; (A_{11} + A_{22})(B_{11} + B_{22})\\<br>M_6 &#x3D; (A_{12} - A_{22})(B_{21} + B_{22})\\<br>M_7 &#x3D; (A_{11} - A_{21})(B_{11} + B_{12})<br>$$<br>做了这7次乘法后，在做若干次加减法，就可以得到：<br>$$<br>C_{11} &#x3D; M_5 + M_4 - M_2 + M_6\\<br>C_{12} &#x3D; M_1 +M_2\\<br>C_{21} &#x3D; M_3 + M_5\\<br>C_{22} &#x3D; M_5 + M_1 - M_3 - M_7<br>$$<br>Strassen矩阵乘法中用了7次对于n&#x2F;2阶矩阵乘积的递归调用和18次n&#x2F;2阶矩阵的加减运算。由此可知，<strong>Strassen算法的时间复杂度T(n)为</strong>：<br>$$<br>T(n) &#x3D;<br>\begin{cases}<br>O(1) &amp; n &#x3D; 2\\<br>7T(n&#x2F;2) + O(n^2) &amp; n&gt;2<br>\end{cases}<br>$$<br>由此解递归方程得$ T(n) &#x3D; O(n^{log7}) &#x3D; O(n^{2.81}) $</p><h3 id="4-棋盘覆盖"><a href="#4-棋盘覆盖" class="headerlink" title="4.棋盘覆盖"></a>4.棋盘覆盖</h3><h4 id="1-什么是棋盘覆盖"><a href="#1-什么是棋盘覆盖" class="headerlink" title="1.什么是棋盘覆盖"></a>1.什么是棋盘覆盖</h4><p><strong>首先需要引入两个概念：什么是特殊方格？什么是特殊棋盘？</strong><br>在一个$ 2^k \times 2^k $个方格组成的期盼中，若恰有一个方格与其他方格不同，则称该方格为特殊方格，且该棋盘为特殊棋盘。</p><p><strong>然后再引出棋盘覆盖问题：</strong><br>在棋盘覆盖问题中，要用如下图所示的4种形态不同的L型骨牌覆盖一个给定的特殊棋盘上除特殊方格以外的其他方格，且任何两个L型骨牌不可相互重叠。除此以外，我们容易知道，覆盖一个特殊棋盘需要用到$ (4^k - 1)&#x2F;3 $个骨牌数。<br><img src="https://img-blog.csdnimg.cn/20200707141724222.png"><img src="https://img-blog.csdnimg.cn/20200707141821358.png"></p><h4 id="2-解决棋盘覆盖的思想方法"><a href="#2-解决棋盘覆盖的思想方法" class="headerlink" title="2.解决棋盘覆盖的思想方法"></a>2.解决棋盘覆盖的思想方法</h4><p>用分治策略，可以设计解棋盘覆盖问题的一个简便的算法。当k&gt;0时，将$ 2^k \times 2^k  $棋盘分割为4个$ 2^{k-1} \times 2^{k-1} $子棋盘。如图所示(a)，特殊方格必位于4个较小子棋盘之一中，其余三个子棋盘中无特殊方格。为了将这三个无特殊方格的子棋盘转化为特殊棋盘，可以用一个L型骨牌覆盖这三个较小棋盘的会和处，如图(b)所示，这三个子棋盘上被L型骨牌覆盖的方格就成为该棋盘上的特殊方格，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归的使用这种份分割，直至棋盘转化为$ 1 \times 1$棋盘。<br><img src="https://img-blog.csdnimg.cn/20200707145142306.png"></p><h4 id="3-棋盘覆盖的代码"><a href="#3-棋盘覆盖的代码" class="headerlink" title="3.棋盘覆盖的代码"></a>3.棋盘覆盖的代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token class-name">ChessBoard</span><span class="token punctuation">(</span><span class="token keyword">int</span> tr<span class="token punctuation">,</span><span class="token keyword">int</span> tc<span class="token punctuation">,</span><span class="token keyword">int</span> dr<span class="token punctuation">,</span><span class="token keyword">int</span> dc<span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token keyword">int</span> t <span class="token operator">=</span> tile<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">int</span> s <span class="token operator">=</span> size<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//覆盖左上角子棋盘</span><span class="token keyword">if</span><span class="token punctuation">(</span>dr <span class="token operator">&lt;</span> tr <span class="token operator">+</span> s <span class="token operator">&amp;&amp;</span> dc <span class="token operator">&lt;</span> tc <span class="token operator">+</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token punctuation">,</span> tc<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>board<span class="token punctuation">[</span>tr<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>tc<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token punctuation">,</span> tc<span class="token punctuation">,</span> tr<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//覆盖右上角子棋盘</span><span class="token keyword">if</span><span class="token punctuation">(</span>dr <span class="token operator">&lt;</span> tr <span class="token operator">+</span> s <span class="token operator">&amp;&amp;</span> dc <span class="token operator">>=</span> tc <span class="token operator">+</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>board<span class="token punctuation">[</span>tr<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>tc<span class="token operator">+</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token punctuation">,</span> tr<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//覆盖左下角棋盘</span><span class="token keyword">if</span><span class="token punctuation">(</span>dr <span class="token operator">>=</span> tr<span class="token operator">+</span>s <span class="token operator">&amp;&amp;</span> dc <span class="token operator">&lt;</span> tc<span class="token operator">+</span>s <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token operator">+</span>s<span class="token punctuation">,</span> tc<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>board<span class="token punctuation">[</span>tr<span class="token operator">+</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>tc<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token operator">+</span>s<span class="token punctuation">,</span> tc<span class="token punctuation">,</span> tr<span class="token operator">+</span>s<span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//覆盖右下角</span><span class="token keyword">if</span><span class="token punctuation">(</span>dr <span class="token operator">>=</span> tr<span class="token operator">+</span>s <span class="token operator">&amp;&amp;</span> dc <span class="token operator">>=</span> tc<span class="token operator">+</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token operator">+</span>s<span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>board<span class="token punctuation">[</span>tr<span class="token operator">+</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>tc<span class="token operator">+</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token class-name">ChessBoard</span><span class="token punctuation">(</span>tr<span class="token operator">+</span>s<span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token punctuation">,</span> tr<span class="token operator">+</span>s<span class="token punctuation">,</span> tc<span class="token operator">+</span>s<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* * Board:表示棋盘 * tile:全局变量表示L型骨牌的编号，其初始值为0 * tr:棋盘左上角方格的行数 * tc:棋盘左上角方格的列数 * dr:特殊方格所在的行号 * dc:特殊方格所在的列号 * size:size=2^k,棋盘规格为2^k * 2^k */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-分治法解决棋盘覆盖的复杂度"><a href="#4-分治法解决棋盘覆盖的复杂度" class="headerlink" title="4.分治法解决棋盘覆盖的复杂度"></a>4.分治法解决棋盘覆盖的复杂度</h4><p>分治法的得出的时间复杂度T(n)的递归方程是：<br>$$<br>T(n)<br>\begin{cases}<br>&#x3D;O(1) &amp; k&#x3D;0\\<br>&#x3D;4T(k-1) + O(1) &amp; k &gt; 0<br>\end{cases}<br>$$<br>解递归方程得$ T(n) &#x3D; O(4^k) $</p><h3 id="5-合并排序"><a href="#5-合并排序" class="headerlink" title="5.合并排序"></a>5.合并排序</h3><h4 id="1-合并排序的基本思想"><a href="#1-合并排序的基本思想" class="headerlink" title="1.合并排序的基本思想"></a>1.合并排序的基本思想</h4><p>合并排序是用分治法实现对n个元素排序的算法。其基本思想是：将待排序元素分成大小大致相同的两个子集合，如果子集合中的元素个数为1，则返回，否则对这两个集合继续进行合并排序，排好序后用一个合并函数将两个子集合合并即可。</p><h4 id="2-合并排序的代码"><a href="#2-合并排序的代码" class="headerlink" title="2.合并排序的代码"></a>2.合并排序的代码</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//递归形式的合并排序</span><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>    <span class="token comment">//数组中只有一个元素</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token comment">//数组中有多个元素</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left0 <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> k <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            b<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            b<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">></span> mid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>k <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            b<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">></span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            b<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        a<span class="token punctuation">[</span>left0<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-Master定理"><a href="#3-Master定理" class="headerlink" title="3.Master定理"></a>3.Master定理</h4><p>$$<br>\text{在递推式}<br>T(n)&#x3D;kT(n&#x2F;m)+f(n)<br>\text{中,}<br>f(n) &#x3D; n^{d}<br>\text{,}<br>d \ge 0<br>\text{,则}\\<br>T(n) &#x3D;<br>\begin{cases}<br>O(n^{d}) &amp; k &lt; m^{d}\\<br>O(n^{d}log_{m}n) &amp; k &#x3D; m^{d}\\<br>O(n^{log_{m}k}) &amp; k &gt; m^{d}<br>\end{cases}<br>$$</p><h4 id="4-合并排序的时间复杂度"><a href="#4-合并排序的时间复杂度" class="headerlink" title="4.合并排序的时间复杂度"></a>4.合并排序的时间复杂度</h4><p><strong>合并排序算法的时间复杂度T(n)的递归方程为：</strong><br>$$<br>T(n)<br>\begin{cases}<br>O(1) &amp; n \le 1 \\<br>2T(n&#x2F;2)+O(n) &amp; n \gt 1<br>\end{cases}<br>$$<br>根据master解得**T(n)&#x3D;O(nlogn)**。</p><p>由于排序问题的渐进时间下界为O(nlogn)，所以<strong>合并算法是一个渐进最优算法</strong>。</p><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h3><h4 id="1-快速排序的基本思想"><a href="#1-快速排序的基本思想" class="headerlink" title="1.快速排序的基本思想"></a>1.快速排序的基本思想</h4><p>快速排序算法是基于分治策略的排序算法。其基本思想是对输入的子数组a[p:r]，按以下三个步骤进行排序。</p><p>1.分解：以a[p]为基准元素将a[p:r],分成三段a[p:q-1],a[q],a[q+1,r]，使得a[p:q-1]中的元素都小于a[q],同时a[q+1:r]中的元素都大于a[q],下标是划分后一开始a[p]的值对应的下标。</p><p>2.递归求解：递归调用快速排序算法，对a[p,q-1]和a[q+1;r]求解</p><p>3.合并：因为排序是就地进行的，所以排好序后不需要进行任何计算，a[p:r]就已经排好序了.</p><h4 id="2-快速排序的代码"><a href="#2-快速排序的代码" class="headerlink" title="2.快速排序的代码"></a>2.快速排序的代码</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">quickSqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> q<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>p<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSqrt</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>p<span class="token punctuation">,</span><span class="token punctuation">(</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSqrt</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token punctuation">(</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> p<span class="token punctuation">,</span> j <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> a<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> x<span class="token punctuation">)</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-快速排序的时间复杂度"><a href="#3-快速排序的时间复杂度" class="headerlink" title="3.快速排序的时间复杂度"></a>3.快速排序的时间复杂度</h4><p>快速排序算法的时间复杂度的递归方程为：<br>$$<br>\text{在最坏情况下}\\<br>T(n)&#x3D;<br>\begin{cases}<br>O(1) &amp; n \le 1 \\<br>T(n-1) + O(n) &amp; n \gt 1<br>\end{cases}\\<br>\text{解递归方程得：}T(n) &#x3D; O(n^{2})\\<br>\text{在最好情况下}\\<br>T(n)&#x3D;<br>\begin{cases}<br>O(1) &amp; n \le 1 \\<br>T(n&#x2F;2) + O(n) &amp; n \gt 1<br>\end{cases}\\<br>\text{解递归方程得：}T(n) &#x3D; O(nlogn)<br>$$<br>可以证明<strong>快速排序在平均情况下得时间复杂度也为T(n)&#x3D;O(nlogn);</strong></p><p>快速排序得时间复杂度取决于划分的对称性，可以随机选择基准数，从而可以期望划分是比较对称的。</p><h3 id="7-循环赛日程表"><a href="#7-循环赛日程表" class="headerlink" title="7.循环赛日程表"></a>7.循环赛日程表</h3><h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h4><p>设有n&#x3D;2k个运动员要进行网球循环赛。现要设计一个满足以下要求的比赛日程表：</p><ol><li>每个选手必须与其他n-1个选手各赛一次；</li><li>每个选手一天只能参赛一次；</li><li>循环赛在n-1天内结束。<br>按此要求可将比赛日程表设计成有n行和(n-1)列的表。在表中第i行和第j列处填入第i个选手在第j天所遇到的选手。</li></ol><h4 id="2-分治策略算法的基本思想"><a href="#2-分治策略算法的基本思想" class="headerlink" title="2.分治策略算法的基本思想"></a>2.分治策略算法的基本思想</h4><p>如图，所列出的正方形表是8个选手的比赛日程表。其中左上角与左下角的两小块分别为选手 1 至选手 4 和选手 5 至选手 8 前3天的比赛日程。据此，将左上角小块中的所有数字按其相对位置抄到右下角，又将左下角小块中的所有数字按其相对位置抄到右上角，这样我们就分别安排好了选手1至选手4和选手5至选手8在后4天的比赛日程。依此思想容易将这个比赛日程表推广到具有任意多个选手的情形。</p><p>$$<br>\begin{matrix}<br>1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 \\<br>2 &amp; 1 &amp; 4 &amp; 3 &amp; 6 &amp; 5 &amp; 8 &amp; 7 \\<br>3 &amp; 4 &amp; 1 &amp; 2 &amp; 7 &amp; 8 &amp; 5 &amp; 6 \\<br>4 &amp; 3 &amp; 2 &amp; 1 &amp; 8 &amp; 7 &amp; 6 &amp; 5 \\<br>5 &amp; 6 &amp; 7 &amp; 8 &amp; 1 &amp; 2 &amp; 3 &amp; 4\\<br>6 &amp; 5 &amp; 8 &amp; 7 &amp; 2 &amp; 1 &amp; 4 &amp; 3\\<br>7 &amp; 8 &amp; 5 &amp; 6 &amp; 3 &amp; 4 &amp; 1 &amp; 2\\<br>8 &amp; 7 &amp; 6 &amp; 5 &amp; 4 &amp; 3 &amp; 2 &amp; 1\\<br>\end{matrix}<br>$$<br>3.核心代码</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void schedule(int k, int n, int** array)   &#x2F;&#x2F; 数组下标从1开始&#123;    for (int i &#x3D; 1;i &lt;&#x3D; n;i++)  &#x2F;&#x2F; 第一行排1-n        array[1][i] &#x3D; i;        int m &#x3D; 1;  &#x2F;&#x2F; 用来控制每一次填表时i行j列的起始填充位置        for (int s &#x3D; 1;s &lt;&#x3D; k;s++)  &#x2F;&#x2F; k指分成k大部分进行填充日程表；s指第几大部分    &#123;        n &#x3D; n &#x2F; 2;        for (int t &#x3D; 1;t &lt;&#x3D; n;t++)  &#x2F;&#x2F; 第s部分内的循环        &#123;            for (int i &#x3D; m + 1;i &lt;&#x3D; 2 * m;i++) &#x2F;&#x2F; 行            &#123;                for (int j &#x3D; m + 1;j &lt;&#x3D; 2 * m;j++) &#x2F;&#x2F; 列                &#123;                    array[i][j + (t - 1) * m * 2] &#x3D; array[i - m][j + (t - 1) * m * 2 - m];       &#x2F;&#x2F;左上角等于右下角的值                    array[i][j + (t - 1) * m * 2 - m] &#x3D; array[i - m][j + (t - 1) * m * 2];       &#x2F;&#x2F;左下角等于右上角的值                &#125;            &#125;        &#125;        m *&#x3D; 2;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法设计与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Hexo博客并且部署到GitHub</title>
      <link href="/2022/03/09/hexo-hithub/"/>
      <url>/2022/03/09/hexo-hithub/</url>
      
        <content type="html"><![CDATA[<h3 id="一，下载Nodejs-git-hexo"><a href="#一，下载Nodejs-git-hexo" class="headerlink" title="一，下载Nodejs,git,hexo"></a>一，下载Nodejs,git,hexo</h3><ol><li><p>Nodejs下载网址：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p><p>检查是否安装成功：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">node -vnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li><p>git下载网址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>检查是否安装成功：<code>git --version</code></p></li><li><p>hexo下载：<code>npm install hexo-cli -g</code><br>检查是否安装成功：<code>hexo -v</code></p></li></ol><h3 id="二，搭建仓库"><a href="#二，搭建仓库" class="headerlink" title="二，搭建仓库"></a>二，搭建仓库</h3><ol><li><p>github注册账号</p></li><li><p>新建仓库</p><p>​    Repository名称：用户名.github.io</p><p>​    权限：public</p><p>​    勾选：ADD a README file</p></li></ol><h3 id="三，生成ssh密钥并绑定："><a href="#三，生成ssh密钥并绑定：" class="headerlink" title="三，生成ssh密钥并绑定："></a>三，生成ssh密钥并绑定：</h3><ol><li><p>生成ssh密钥：<code>ssh-keygen -t rsa -C &quot;GitHub邮箱地址&quot;</code></p></li><li><p>在用户文件夹下的.ssh文件夹下找到公钥：id_rsa.pub</p></li><li><p>将公钥复制填写到你的GitHub上绑定</p></li><li><p>检测ssh密钥是否绑定成功：ssh -T <a href="mailto:&#x67;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#x6d;">&#x67;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#x6d;</a></p></li></ol><h3 id="四，搭建本地博客"><a href="#四，搭建本地博客" class="headerlink" title="四，搭建本地博客"></a>四，搭建本地博客</h3><ol><li><p>新建一个文件夹blog</p></li><li><p>在该文件夹里初始化hexo博客： hexo init</p></li><li><p>在本地部署服务器查看 hexo s</p></li></ol><h3 id="五，部署到github"><a href="#五，部署到github" class="headerlink" title="五，部署到github"></a>五，部署到github</h3><ol><li>将根目录下的_config.yml中最后一行修改添加为：</li></ol><pre class="line-numbers language-none"><code class="language-none">deploy: type: gitrepository: 你的仓库地址branch: main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>安装hexo-deployer-git</li></ol><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>生成静态文件</li></ol><pre class="line-numbers language-none"><code class="language-none">hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>设置邮箱和用户名</li></ol><pre class="line-numbers language-none"><code class="language-none">git config --global user.email &quot;你的邮箱&quot;git config --global user.name &quot;你的用户名&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="5"><li>将静态文件上传到GitHub</li></ol><pre class="line-numbers language-none"><code class="language-none">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意：第一次上传需要用githun生成token</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
